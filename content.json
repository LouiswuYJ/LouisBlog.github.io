{"meta":{"title":"Louis's Blog","subtitle":null,"description":"Stressed is just desserts if you can reverse.","author":"Louis Wu","url":"https://louiswuyj.site","root":"/LouiswuYJ.github.io/"},"pages":[{"title":"about","date":"2019-10-25T03:16:17.000Z","updated":"2020-09-19T12:37:58.428Z","comments":true,"path":"about/index.html","permalink":"https://louiswuyj.site/about/index.html","excerpt":"","text":"Louis Wu喜歡戶外活動卻沈迷於寫code的矛盾野男。 Skills Ruby on Rails MVC / RESTful / TDD / RSpec PostgreSQL / Relational Database / ER diagram HTML5 / CSS / Bootstrap / RWD Git / GitHub / Git-Flow ProjectBreakwaste 2019/09 ~ 2019/10https://github.com/LouiswuYJ/breakwaste"},{"title":"categories","date":"2020-09-20T05:30:35.000Z","updated":"2020-09-20T05:49:34.096Z","comments":true,"path":"categories/index.html","permalink":"https://louiswuyj.site/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-09-20T05:30:35.000Z","updated":"2020-09-20T06:03:40.757Z","comments":true,"path":"tags/index.html","permalink":"https://louiswuyj.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"簡介 OpenStruct 跟 Struct","slug":"2019/2020/簡介 OpenStruct 跟 Struct","date":"2020-10-22T10:00:00.000Z","updated":"2020-10-22T06:48:37.288Z","comments":true,"path":"2019/2020/簡介 OpenStruct 跟 Struct/","link":"","permalink":"https://louiswuyj.site/2019/2020/%E7%B0%A1%E4%BB%8B%20OpenStruct%20%E8%B7%9F%20Struct/","excerpt":"","text":"簡介 OpenStruct 跟 Struct還記得龍哥說，Ruby 是個物件化很徹底的程式語言，幾乎全部的東西都是物件(除了 block），我們更常使用 class 來實現物件導向，但若只是想做個小東西的話，其實也不一定需要寫到 polo 去解決。 為什麼我們需要模擬class物件呢？主要是一個物件有一些些屬性需要存取，例如一篇文章Post底下只需要title和content兩個屬性，用class來存取就是用牛刀殺雞，太過複雜，用簡單的Hash存取即可。 123456post = &#123;'title': '為什麼一直單身？', 'content': '憑實力的你不懂!!'&#125;[4] pry(main)&gt; post[:title]=&gt; \"小菜為什麼一直單身？\"[5] pry(main)&gt; post[:content]=&gt; \"憑實力你不懂!!\" 123456789101112class Post def initialize end def title puts \"小菜為什麼一直單身？\" end def content puts \"憑實力你不懂!!\" endend (當然也可以用 attr_accessor 來簡化啦，但今天重點不是這個XD) 如果屬性的範圍介於簡單跟複雜之間 但Hash其實在某些功能上過於簡單，存取的功能較不方便，假如要模擬的class更為複雜，就需要OpenStruct 或 Struct 協助。 定義：A struct is a built-in Ruby class, it’s used to create new classes which produce value objects. A value object is used to store related attributes together. 等等會給大家看看為何我們公司的專案會需要用 Struct 來實作。 Openstruct使用起來很像 Hash 1234567891011121314151617181920212223242526272829303132333435require 'ostruct'# OpenStruct class不包含在原本Core物件當中，因此需要先requirepost = OpenStruct.new(title: \"小菜說\", content: \"你必須很努力\")=&gt; #&lt;OpenStruct title=\"小菜說\", content=\"你必須很努力\"&gt;# 讀取post.title # =&gt; \"小菜\"post[:title] # =&gt; \"小菜\"post[\"title\"] # =&gt; \"小菜\"post.content # =&gt; \"你必須很努力\"post[:content] # =&gt; \"你必須很努力\"post[\"content\"] # =&gt; \"你必須很努力\"# 寫入post.title = \"丁丁\"post[:title] = \"丁丁\"post[\"title\"] = \"丁丁\"post.title # =&gt; \"丁丁\"post[:title] # =&gt; \"丁丁\"post[\"title\"] # =&gt; \"丁丁\"# 我們也可以隨意新增屬性post.say = \"只有午休跟下班\"post[:say] = \"只有午休跟下班\"post[\"say\"] = \"只有午休跟下班\"post.say # =&gt; \"只有午休跟下班\"post[:say] # =&gt; \"只有午休跟下班\"post[\"say\"] # =&gt; \"只有午休跟下班\"post=&gt; #&lt;OpenStruct title=\"小菜說\", content=\"你必須很努力\", say=\"只有午休跟下班\"&gt; 可以看得出來 OpenStruct 的使用非常方便，可以直接把屬性當作 method 來處理，可以任意指定屬性內容、讀取，且不管用 string 或 symbol 當做 key 都可用，使用起來非常自由。 缺點： 效能較 Struct 差 沒辦法克制 method 來使用，Struct 可以 Struct用起來的手感比較像使用 class 12345678910111213141516171819202122232425# 宣告時需要先行定義屬性Post = Struct.new(:title, :content)post = Post.new(\"小菜\", \"看起來毫不費力\")=&gt; #&lt;struct Post title=\"小菜\", content=\"看起來毫不費力\"&gt;# 讀取的方式與OpenStruct一樣自由post.title # =&gt; \"小菜\"post[:title] # =&gt; \"小菜\"post[\"title\"] # =&gt; \"小菜\"post.content # =&gt; \"看起來毫不費力\"post[:content] # =&gt; \"看起來毫不費力\"post[\"content\"] # =&gt; \"看起來毫不費力\"# 但無法隨時新增屬性post.me = \"只有我看起很費力\"# =&gt; NoMethodError: undefined method `me=' for #&lt;struct Post title=\"小菜\", content=\"123\"&gt;# 若在宣告Struct instance時，未帶入的變數會自動變成nilpost = Post.new(\"小菜\")post.content# =&gt; nil# 同樣的，宣告時帶入太多參數會產生錯誤，比 OpenStruct 嚴謹許多post = Post.new(\"小菜\", 7, \"other stuff\")# =&gt; ArgumentError: struct size differs 但 Struct 很好用的是可以在定義時帶入block，並寫 method： 12345678Post = Struct.new(:title, :content) do def say \"#&#123;title&#125;: #&#123;content&#125;\" endendpost = Post.new(\"丁丁\", \"我只有午休跟下班的時候\")post.say # =&gt; \"丁丁: 我只有午休跟下班的時候\" 未完待續.. 參考資料:How to Use Struct &amp; OpenStruct in RubyRuby - Struct vs OpenStruct模擬class物件：Ruby當中Struct及OpenStruct的使用","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"如何把 iterm2 oh-my-zsh 的路徑變短","slug":"2019/如何把 iterm2 oh-my-zsh 的路徑變短","date":"2019-11-15T04:10:40.000Z","updated":"2020-09-30T06:41:32.097Z","comments":true,"path":"2019/如何把 iterm2 oh-my-zsh 的路徑變短/","link":"","permalink":"https://louiswuyj.site/2019/%E5%A6%82%E4%BD%95%E6%8A%8A%20iterm2%20oh-my-zsh%20%E7%9A%84%E8%B7%AF%E5%BE%91%E8%AE%8A%E7%9F%AD/","excerpt":"","text":"若擔心改壞的話，建議可以先備份原始的 agnoster.zsh-theme 檔後再進行編輯。 查了很多方法都不可行，後來發現只要按照以下步驟的話，就可以順利把路徑縮短。 步驟1. 找到 .oh-my-zsh/themes 資料夾1open ~/.oh-my-zsh/themes 步驟2. 打開 themes 資料夾底下的 agnoster.zsh-theme (文件檔)看個人習慣要用vim開還是一般的文字編輯器都可以: 步驟3. 找到 prompt_dir() 並加入數字原始: 1234# Dir: current working directoryprompt_dir() &#123; prompt_segment blue $CURRENT_FG '%~'&#125; 數字1: 代表顯示1層12345# Dir: current working directoryprompt_dir() &#123;# prompt_segment blue $CURRENT_FG '%~' prompt_segment blue $CURRENT_FG '%1~'&#125; 數字2: 代表顯示2層12345# Dir: current working directoryprompt_dir() &#123;# prompt_segment blue $CURRENT_FG '%~' prompt_segment blue $CURRENT_FG '%2~'&#125; 以此類推 參考資料：How to shorten zsh prompt (oh my zsh)","categories":[{"name":"開發相關","slug":"開發相關","permalink":"https://louiswuyj.site/categories/%E9%96%8B%E7%99%BC%E7%9B%B8%E9%97%9C/"}],"tags":[{"name":"iterm2","slug":"iterm2","permalink":"https://louiswuyj.site/tags/iterm2/"}]},{"title":"Day30: 我竟然完賽了？","slug":"2019/鐵人賽Day 30","date":"2019-10-13T04:10:40.000Z","updated":"2020-09-29T09:18:56.635Z","comments":true,"path":"2019/鐵人賽Day 30/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2030/","excerpt":"","text":"在這裡，我要感謝我的父母#%#$@!@^&amp;（誤 看第1天的“參賽起始文”，還清楚記得發文當下的感覺： “我自己真的能做到嗎？”寫到了第30天，真的不敢相信自己竟然真的完賽了!? 過程中真的頗痛苦，但好像已經默默的養成每天早上起來看文件的習慣，說進步嗎..? 或許有、或許沒有，至少證實了一句話： 「時間就像擠乳溝，硬擠一下就有了。」 這30篇文章有很多可以改進跟修正的地方(尤其廢文)，還好這次是報名自我挑戰組，心態上也比較不一樣，也許明年挑戰Mordern Web組的時候又是另一個挑戰跟態度了吧！(什麼..你竟然還想再挑戰？) 這次雖然有完賽，其實不能說都是靠自己的力量，回頭想想，如果沒有身邊夥伴的互相鼓勵跟支持，我覺得只靠我自己是不可能完賽的，很感謝他們。 說到夥伴們就覺得感慨，在五倍這邊也只剩下不到一週的時間就要結束了，雖然這裡是鐵人賽，但就像第1天說的，就當是寫給自己看的。 如果沒有“某菜”每天的嘴砲注入點活力，也許我不會走到現在。如果沒有“某叔”在CRUD時耐心教我，我想我應該早就放棄了。如果沒有“某聰”對於程式的求知慾，我想我對於寫程式應該不會感到有興趣。如果沒有“某凡”逆流而上的態度，我應該早就被壓力擊垮了。如果沒有“某尼”的強大，我就不會意識到自己離車尾燈還有多麼遙遠。 (夥伴、饅頭真的真的在這行很重要啊!!!) 五倍Astrocamp跟鐵人賽的結束，只是一個「進入新手村」開始，我才剛創建好角色準備踏入而已，期許自己幾年後回頭看看現在的自己會忍不住大噴一番XD 鐵人賽，我們明年見！ “Would you like me to give you a formula for success? It’s quite simple, really. Double your rate of failure. You’re thinking of failure as the enemy of success. But it isn’t at all… You can be discouraged by failure – or you can learn from it. So go ahead and make mistakes. Make all you can. Because, remember that’s where you’ll find success. On the far side.” – Thomas J. Watson, Founder of IBM","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day29: Rails - Active Storage","slug":"2019/鐵人賽Day 29","date":"2019-10-12T04:10:40.000Z","updated":"2020-09-29T09:18:56.597Z","comments":true,"path":"2019/鐵人賽Day 29/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2029/","excerpt":"","text":"最近做專案遇到了上傳檔案的問題，想針對這個主題簡單的做個介紹。 Active Storage Active Storage可以將文件上傳到Amazon S3，Google Cloud Storage或Microsoft Azure Storage等雲存儲服務，並將這些文件附加到Active Record。 它是一個可以用於開發或測試的服務，並可將文件進行備份和遷移。 其中，使用Active Storage，可以使用ImageMagick轉換圖像上傳，上傳非圖像或圖像（如PDF或影片）的檔案，並可任意從文件中存取。 by Rails Guide-Active Storage Overview 據 Rails 官方文件說明，Active Storage 是在 Rails 5.2版後才推出的功能，在它之前似乎多數人都使用 Paperclip 及 CarrierWave，這次將會已上傳圖片為例來做說明。 在開始之前，得先在終端機執行以下指令： 12rails active_storage:installrails db:migrate 第一行會產生兩個table的migration： 123456789101112131415161718192021222324252627# This migration comes from active_storage (originally 20170806125915)class CreateActiveStorageTables &lt; ActiveRecord::Migration[5.2] def change create_table :active_storage_blobs do |t| t.string :key, null: false t.string :filename, null: false t.string :content_type t.text :metadata t.bigint :byte_size, null: false t.string :checksum, null: false t.datetime :created_at, null: false t.index [ :key ], unique: true end create_table :active_storage_attachments do |t| t.string :name, null: false t.references :record, null: false, polymorphic: true, index: false t.references :blob, null: false t.datetime :created_at, null: false t.index [ :record_type, :record_id, :name, :blob_id ], name: \"index_active_storage_attachments_uniqueness\", unique: true t.foreign_key :active_storage_blobs, column: :blob_id end endend db:migrate之後，就可以看到 schema.rb 已新增兩個 table： active_storage_blobs: 存放附檔資訊active_storage_attachments: 存放附檔和 model 的關聯 其中附加檔案的方式有分成一個 model 一個檔案或甚至多個檔案，我們先已有個food model舉例： 一個食物一個檔案1234#food.rbclass Food &lt; ApplicationRecord has_one_attached :avatarend 其實在schema裡是看不到avatar這個欄位，可以想成是“虛擬欄位的概念”。 如果要做個可以上傳的表單的話，可以利用 form_for來實現： 1234567#@foods = Food.all&lt;%= form_for(@foods) do |form| %&gt; &lt;%= form.label :avatar, '檔案上傳', &lt;%= form.file_field :avatar%&gt;#下略&lt;% end %&gt; Strong parameter只要是丟資料到網站上，都需要permit才可以，故要在params的地方也要記得要加上:avatar去permit。 123def clean_params params.require(:food).permit(:title, :address, :phone, :quantity, :origin_price, :discount_price, :pickup_time, :picture, :description, :endup_time, :avatar)end 要新增檔案可以用： 1food.avatar.attach(params[:avatar]) 若要確定是否有附加檔案的話，可以用： 123food.avatar.attached?# 回傳boolean值 一個食物多個檔案差異其實只有兩個： 改成has_many_attached 12345#food.rbclass Food &lt; ApplicationRecord #has_one_attached :avatar has_many_attached :avatarsend 改成陣列型式avatars:[] 123def clean_params params.require(:food).permit(:title, :address, :phone, :quantity, :origin_price, :discount_price, :pickup_time, :picture, :description, :endup_time, avatars:[])end 關於“新增檔案”及“確定是否有附加檔案”的方式是一樣的，只是記得avatar要用複數形式(avatars) 附加完檔案了，如果是照片的話要如何顯示呢？ mini_magick在Rails的 Gemfile 其實有內建一個套件 mini_magick，若要做圖片顯示的效果，可以把註解拿掉 bundle 後就可以用了。 123#Gemfile# Use ActiveStorage variantgem &apos;mini_magick&apos;, &apos;~&gt; 4.8&apos; 1&lt;%= image_tag food.avatar.variant(resize: '300x300'), if food.avatar.attached?%&gt; variant方法是用來改變上傳的圖片尺寸if food.avatar.attached? 有附加檔案的話就印出圖片。 如果沒有加上這個判斷的話，今天頁面的某個檔案若剛好沒有附加檔案，就會噴錯，原因是“food.avatar是nil，不能對nil做variant方法”。 參考資料： Rails Guides - Active Storage OverviewActive Storage 開箱文[Rails] Active Storage Overview “Don’t worry about failure; you only have to be right once.” — Drew Houston, Entrepreneur","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day28: 用個Github來版本控制吧 ","slug":"2019/鐵人賽Day 28","date":"2019-10-11T04:10:40.000Z","updated":"2020-09-29T09:18:56.570Z","comments":true,"path":"2019/鐵人賽Day 28/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2028/","excerpt":"","text":"之前都在寫Rails相關的內容，其實版本控制也是重要的一環，就來換個口味寫個GitHub吧～ 登入GitHub後第一步 加號點開後，請點選紅框 New repository 新增專案 輸入自訂的檔名，依照你想要公開(Public)或私人(Private)去選擇後，按下方 Create repository 選擇透過 HTTPS / SSH 的方式來上傳檔案 HTTPS是加密網站，使用上囉嗦(每次都要輸入帳密)但設定上簡單。SSH則是公鑰跟私鑰，但這設定上要key一些指令，這不是此次討論的範圍，有興趣請點這裡設定。 Create a new repository 顧名思義就是直接產生一個新的專案，而 Push an exisiting repository 意思是與直接本地端的專案做版控，此次我們選擇後者。 12345678910git remote add origin https://github.com/LouiswuYJ/testing.git 遠端 新增 代名詞 位置-&gt; 將本地端的git版本整包與GitHub上連結git push -u origin master 代名詞 分支-&gt; 新增一個代名詞節點，這裡的-u 代表設定上線(upstream)，把自己本地端的分支(master)推到網站上，且u設定一次之後，orign 就已經變成預設值，所以以後只要git push 即可。git remote -v-&gt;查看remote狀況 再開始之前，先隨便找一個有git版控的檔案，若沒有的話再建一個就好。 12345開終端機到指定資料夾後:git init -&gt; 初始化touch 檔案 -&gt;新增檔案git add . -&gt;將全部檔案 addgit commit -m &quot;自訂&quot; -&gt;commit後產生第一個分支 本地端我先設2個(commit)節點後，下上述兩個指令後就會與GitHub上做連結。 1234567891011git remote add origin https://github.com/LouiswuYJ/testing.git$ git push -u origin masterEnumerating objects: 5, done.Counting objects: 100% (5/5), done.Delta compression using up to 4 threadsCompressing objects: 100% (3/3), done.Writing objects: 100% (5/5), 407 bytes | 135.00 KiB/s, done.Total 5 (delta 0), reused 0 (delta 0)To https://github.com/LouiswuYJ/testing.git* [new branch] master -&gt; masterBranch &apos;master&apos; set up to track remote branch &apos;master&apos; from &apos;origin&apos;. git push (從本地推上遠端)123git push origin mastergit push -f直接檔案蓋掉全部，建議要用之前最好先告知你的其他團隊成員，不然就... 新增了檔案03.html並commit後push到Github，本地端的 master 分支，推上GitHub origin 這個遠端節點，並且在遠端形成一個 master 分支，原本GitHub上的2個commit就變3個了。 git fetch (從遠端抓下來)1git fetch origin master 去 origin 這個遠端節點，抓上面 master 分支的內容，並且在我的電腦上建立一個 origin/master 分支，但並不會merge。(白話文:把檔案抓過來，但不會主動合併)情境1: 新增一個檔案後儲存commit變4個，此時用 fetch 後本地就會如下圖所示。 情境2:這邊看到一個origin/master的節點(fetch抓下來) 這時候去merge，就會變這樣 git pull = git fetch + git merge1git pull origin master 去 origin 這個遠端節點，去抓上面 master 分支的內容，並且在電腦上建立一個 origin/master 分支，同時與我本機的 master 分支進行合併白話文: git pull 就是 fetch後再merge的結果。 git clone + Git網址把某個 Git 專案，整包檔案完整複製到自己電腦。 1git clone 網址 共同合作在團隊分工若遇到不能push的時候，可能你團隊的某個人已經先commit過後push上去了，此時可以先pull到自己的檔案後再push上去就可以解決，但如果每次都要先拉再推，會不會顯得有點麻煩? PR = Pull Request如果想幫忙做別人的專案時，=&gt;fork先複製一份到自己的帳號，改好了之後，再發送pull請求給原作者，這個簡易的過程就是大家耳熟能詳的”發PR”。 “If I fail, I try again, and again, and again. If you fail, are you going to try again? The human spirit can handle much worse than we realize. It matters how you are going to finish.” — Nick Vujicic, Motivational Speaker","categories":[{"name":"Git","slug":"Git","permalink":"https://louiswuyj.site/categories/Git/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Git","slug":"Git","permalink":"https://louiswuyj.site/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://louiswuyj.site/tags/GitHub/"}]},{"title":"Day27: Rails關心你的胖Model - concern","slug":"2019/鐵人賽Day 27","date":"2019-10-10T04:10:40.000Z","updated":"2020-09-29T09:18:56.541Z","comments":true,"path":"2019/鐵人賽Day 27/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2027/","excerpt":"","text":"在controller寫方法時，若常常需要用到某個方法，我們會將方法直接寫在Model或上層的application_controller.rb來取用。 已正在進行的專案為例，每個User有一台購物車，除了devise給我們現有的current_user之外，我想在寫個current_cart給每個controller用，此時就可以把定義current_cart的方法寫在application_controller.rb。 1234567class ApplicationController &lt; ActionController::Base private def current_cart @current_cart ||= Cart.find_or_create_by(user: current_user) endend 但有時候並不是每個controller或Model都需要用到這個方法，尤其是把所有要用的方法寫在該類別的Model，會導致Model越來越肥，controller越來越瘦。 有需要的時候再拿進來為了解決這個問題，rails在models下有個資料夾名稱concerns，把定義方法寫在這，在該controller有需要的時候再引入使用就好。 新增一個檔案 usercart.rb 1234567891011121314151617181920212223module Usercart extend ActiveSupport::Concern included do has_one :cart end module ClassMethods def search(search) if search where(['title || description || address LIKE ?', \"%#&#123;search&#125;%\"]) else all end end end private def current_cart @current_cart ||= Cart.find_or_create_by(user: current_user) endend included do ...end 當這個module被include到Model時會做的事：(一對一)有一台購物車ClassMethod 在這裡定義的方法被include時會變成類別方法：可以直接針對該Model做搜尋的方法。current_cart 被include之後會變成該類別的實體方法：如果有找到車就用這台，沒有車就生一台給user。 此時在User的Model加入： 123class User &lt; ApplicationRecord include Usercartend 就可以擁有在concern資料夾下內 usercart.rb 裡的方法可以用了，相對的如果你在其他的Model也想要用的話，再直接include進該Model就好。 參考資料：How to use concerns in Rails 4Rails 程式碼整理術（入門） “Live today. Not yesterday. Not tomorrow. Inhabit your moments. Don’t rent them out to tomorrow.” – Jerry Spinelli, Writer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day26: Rails中的view_helper","slug":"2019/鐵人賽Day 26","date":"2019-10-09T04:10:40.000Z","updated":"2020-09-29T09:18:56.501Z","comments":true,"path":"2019/鐵人賽Day 26/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2026/","excerpt":"","text":"在寫view時，常常會因為過多的邏輯判斷，導致整個view的程式碼非常冗長且難以維護，其實view只是將處理好的資料呈現出來而已，不應該把複雜的邏輯寫在view裡面，此時我們就可以用到helper來解決。 View拿不到controller裡的方法一般在rails裡，view拿不到controller裡的方法，只能拿到對應的action的實體變數，這時候我們就需要用到helper來將方法寫給view使用。 helper的目的是要寫一段ruby code 協助整理資訊，並且可以做兩件事： 在view頁面使用時就可直接使用 也可 include 至 controller使用 簡單來說，只要寫在helper裡的方法，view與comtroller都可以取用。 最近寫專案有寫到購物車，每一個使用者擁有一台車，如果在每次想要撈使用者購物車的資料都要 current_user.cart 的方法去找感覺很麻煩，何不就自己寫個 current_cart 呢？ 解決方式有兩個： 直接寫在helper 方法寫在controller輸出給helper 123#_navbar.html.erb#加入&lt;%= link_to \"購物車(#&#123;current_cart.items.count&#125;)\", \"#\" %&gt; 噴出找不到方法 current_cart，因為還沒寫嘛！ 直接寫在helper讓view取得helper方法在寫helper之前，要先注意命名的對應，檔名如果是products_helper.rb，則檔案內的 module 後就得寫 ProductsHelper，跟 controller 的命名對應規則是一樣的。 123456#app/helpers/products_helper.rbmodule ProductsHelper def current_cart @cart = @cart || Cart.from_hash(session[:cart123]) endend 如果有車就用這台車，如果沒車就給他一台名叫 cart123的車並存在session，此時的 product.html.erb 就可以使用 current_cart 了。 如果也想讓controller用 讓controller取得helper方法畢竟剛剛寫的helper是個模組，直接 include 進來就好了。 12#products_controller.rbinclude ProductsHelper 方法寫在controller輸出給helper123456#products_controller.rbhelper_method :current_cart#方法寫在這 def current_cart @cart = @cart || Cart.from_hash(session[:cart123]) end 在controller加入 helper_method :current_cart 就可以使helper擁有這個方法，當然view也可以一起使用了。 但如果將方法寫在controller，只有在特定 controller 可以用，如果要全部的controller都可用的話，可貼在最上層的controller： 123456#application_controller.rbhelper_method :current_cart#方法寫在這 def current_cart @cart = @cart || Cart.from_hash(session[:cart123]) end 那我該用哪個方式？這兩種方式都是在讓views拿到controller裡面的方法，至於要選擇哪種方法的判斷標準：Contorller 用得多就寫在 Contorller，view 用得多就寫在 view。 參考資料：Layout, Render 與 View Helper “When you find your path, you must not be afraid. You need to have sufficient courage to make mistakes.” – Paulo Coelho, Novelist","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day25: Rails中的一球冰淇淋 scope","slug":"2019/鐵人賽Day 25","date":"2019-10-08T04:10:40.000Z","updated":"2020-09-29T09:18:56.465Z","comments":true,"path":"2019/鐵人賽Day 25/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2025/","excerpt":"","text":"這個標題、這個圖片，難道是要講什麼吃冰淇淋的感言分享嗎？ 但這真的是我第一次接觸這個名詞腦袋中第一個浮現的畫面XD可能字真的太像了吧(還是只有我這樣覺得？) 看來對我來說，不止中文字有這個問題，好像連英文單字都是… scope, scoop傻傻分不清楚(誤) Scope最近做專案常常發現，在撈資料的時候，常常一直點find點where一直點下去，但有發現有時候在同一個controller時，都在對特定Model做同一件事情，在Rails常常可以看到一個字DRY: Don’t Repeat Yourself 為了能夠讓程式碼變得乾淨易讀且方便使用，我們就可以在該controller的Model寫scope。 也許你會說，可一個一個寫也沒什麼不好啊？ 但如果今天需求變更(例如：原本出全部的資料改為撈價格小於100的資料)，那不就全站都需要跟著修改？非常不方便，所以這時候我們就需要用到scope。 先來看個簡單的例子： 1234#foods_controller.rbdef index @foods = Food.order(create_at: :desc)end 撈出所有Food Model的物件並依照建立時間排序，這時候如果要寫成scope來使用，就可以在Model寫： 1234#food.rbclass Food &lt; ApplicationRecord scope :show_all, -&gt; &#123; order(create_at: :desc) &#125;end 這時候的controller就可以這要取用： 1234#foods_controller.rbdef index @foods = Food.show_allend 如果後面的其他action也要做一樣的事情，就只要在Model名稱(此例為Food)後面加你寫 scope 的方法名稱就可以了。 小補充：1234567891011#food.rbclass Food &lt; ApplicationRecord #寫法一 scope :show_all, -&gt; &#123; order(create_at: :desc) &#125; #寫法二 def self.show_all order(create_at: :desc) endend 寫法一與寫法二的效果是相同的，至於何時該用哪個，其實就是看個人偏好了，我自己的感覺，如果是條件簡單的話就用scope寫，如果是條件較複雜的話就用類別方法寫。 如果想帶參數1234#food.rbclass Food &lt; ApplicationRecord scope :cheap_price, -&gt;(price) &#123; where(\"price &lt; ?\", price)&#125;end 這時候controller就可以拿來用： 1234#foods_controller.rbdef index @foods = Food.cheap_price(price)end scope本身可以帶入scope(串接)12345#food.rbclass Food &lt; ApplicationRecord scope :show_all, -&gt; &#123; order(create_at: :desc).cheap_price(100) &#125; scope :cheap_price, -&gt;(price) &#123; where(\"price &lt; ?\", price)&#125;end 1234#foods_controller.rbdef index @foods = Food.show_price(price)end 這樣的寫法就可以撈出價格小於 price 且按照建立時間排序了。 參考資料：Rails GuideRuby on Rails - Scopes為你自己學Ruby on Rails “Every challenge, every adversity, contains within it the seeds of opportunity and growth.” – Roy Bennett, Politician","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day24: Rails中的find? find_by? where?","slug":"2019/鐵人賽Day 24","date":"2019-10-07T04:10:40.000Z","updated":"2020-09-29T09:18:56.426Z","comments":true,"path":"2019/鐵人賽Day 24/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2024/","excerpt":"","text":"在rails中有多種方法可以去查詢我們要的record，今天就來分別探討最常見的三種方法。 find找出單一筆資料，且只能透過id去搜尋。 12#找出id為1的購物車Cart.find(1) 對應的SQL: 1Cart Load (0.4ms) SELECT \"carts\".* FROM \"carts\" WHERE \"carts\".\"id\" = $1 LIMIT $2 [[\"id\", 1], [\"LIMIT\", 1]] 如果查詢不到該筆資料，就會回傳一個ActiveRecord::RecordNotFound的例外訊息，還記得之前的文章有提過例外處理的方法嗎？ 這時候就可以用begin..rescue來捕捉： 1234567def find_cart begin @cart = Cart.find(params[:id]) rescue redirect_to carts_path, notice: \"沒有這台購物車喔\" end end 如果找不到cart的話，就會直接執行rescue下的程式碼。 若要找多筆資料又堅持用find，find()裡面還可以塞陣列： 123products = Product.find([2, 5]) # 等同於 Client.find(2, 5)#找id是2跟id是5的product find_by找出單一筆資料，且可以透過自訂條件去搜尋。 找出id為5的食物: 123Food.find_by(id: 5)#等同於Food.find(5) 對應的SQL: 1Food Load (0.4ms) SELECT \"foods\".* FROM \"foods\" WHERE \"foods\".\"id\" = $1 LIMIT $2 [[\"id\", 5], [\"LIMIT\", 1]] 找id是2的使用者擁有的食物： 1Food.find_by(user_id: 2) 對應的SQL: 1Food Load (0.2ms) SELECT \"foods\".* FROM \"foods\" WHERE \"foods\".\"user_id\" = $1 LIMIT $2 [[\"user_id\", 2], [\"LIMIT\", 1]] 這裡可以注意的是，如果找不到該筆資料的話，find_by方法會回傳的值是nil而不是例外訊息。 若使用find_by方法撈資料但還是想要有回傳ActiveRecord::RecordNotFound，可以在find_by後面加個驚嘆號! 就可以看到回傳的值不是nil而是可以捕捉的例外訊息了。 where找出多筆資料，且可以透過自訂條件去搜尋，即代表了 SQL 語法 WHERE 的部分。 條件可以是字串、陣列、或是 Hash。 陣列如果我們要找的 orders_count 不是固定的值，則帶入變數params[:orders]： 1Client.where(\"orders_count = ?\", params[:orders]) 根據Rails API文件： 直接將變數插入條件字串裡，不論變數是什麼，都會直接存到資料庫裡。這表示從惡意使用者傳來的變數，會直接存到資料庫。這麼做是把資料庫放在風險裡不管啊！一旦有人知道，可以隨意將任何字串插入資料庫裡，就可以做任何想做的事。 絕對不要直接將變數插入條件字串裡。Hash找id是2的使用者全部擁有的食物： 1Food.where(user_id: 10) 對應的SQL: 1Food Load (0.4ms) SELECT \"foods\".* FROM \"foods\" WHERE \"foods\".\"user_id\" = $1 [[\"user_id\", 10]] 若找不到該筆資料，則會回傳#&lt;ActiveRecord::Relation []&gt;。 參考資料：JD store find/find_by/where in RailsActive Record 查詢[Rails] Active Record Query（SQL Query）Model 基本操作 “Most of our obstacles would melt away if instead of cowering before them we should make up our minds to walk boldly through them.” — Orison Marden, Writer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day23: Rails中的N+1問題","slug":"2019/鐵人賽Day 23","date":"2019-10-06T04:10:40.000Z","updated":"2020-09-29T09:18:56.394Z","comments":true,"path":"2019/鐵人賽Day 23/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2023/","excerpt":"","text":"Rails要建立關聯非常簡單(one-to-one, one-to-many)，但也是這個原因，造成在資料庫查詢的時候浪費許多記憶體，大部分的 ORM 預設使用 lazy-loading，一筆資料的查詢就會產生一筆 query，拖累了資料庫的效能。因此將預設的 lazy-loading 改成 Eager-loading 就可以解決N+1問題。 其中 Eager-loading在 rails 提供了4種方式： preload eagerload includes joins 這篇就拿最常見的inclundes及joins來討論。 我們先建立兩個Model分別為user.rb及product.rb且為一對多關係： 123456789#user.rbclass User &lt; ApplicationRecord has_many :productsend#product.rbclass Product &lt; ApplicationRecord belongs_to :userend controller先將所有的Pdoduct撈出： 12345#products_controller.rbdef index @products = Product.allend 再一筆一筆印出來： 1234567&lt;!-- index.erb.html --&gt; &lt;% @products.each do |product| %&gt; &lt;%= product.user.name%&gt; &lt;%= product.title%&gt; &lt;%= product.price%&gt; .... &lt;% end %&gt; 乍看之下好像很合理，如果說只有一筆product要查這樣寫沒問題，但一個網站怎麼可能只有一筆資料？ 若今天要找出product的擁有者、名字及價錢有10筆。在迭代每筆資料時，一邊呼叫 query 來從 Prdoduct 資料表中取資料，就會產生 10 + 1 次 query，其中後面的 1 指的是 User資料數量。 資料的存取是rails的弱項，所以在設計時能夠避免 N+1問題就避免，將資料存取相關的事交給擅長的資料庫就好。 includes拿上面例子來看，會產生 10+1筆的資料存取，我們可以用includes的方式將所有資料在資料第一次存取時就“一次查完“因此在controller的部份我們可以這樣寫： 12345#products_controller.rbdef index @products = Product.includes(:user)end 再 query 的部分就只會查詢2筆了。 joins與includes的差別:joins 使用 SQL 的 INNER JOIN 方法，不會真的把關聯的資料取出來。如果只是想要篩選結果，或是觀察關聯物件的某些屬性質，那麼使用 :joins 是最有效率的。不過有一點要注意，如果你想要做的事是存取關聯物件本身，那麼 :joins 還是會造成 N+1 問題。 主要差別在於： join主要用於過濾model之間的關係，但對查詢筆數來說並無太大幫助 include主要用於將大量資料在同一筆查詢內一次查好 參考資料： 部分內容擷取自以下連結Preload, Eagerload, Includes and JoinsRails使用include和join避免 N+1 queries[Rails] N+1 Queries ProblemRails API “Tests are a gift. And great tests are a great gift. To fail the test is a misfortune. But to refuse the test is to refuse the gift, and something worse, more &gt;irrevocable, than misfortune.” – Lois McMaster Bujold, writer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day22: 簡易Rails實作(下)","slug":"2019/鐵人賽Day 22","date":"2019-10-05T04:10:40.000Z","updated":"2020-09-29T09:18:56.363Z","comments":true,"path":"2019/鐵人賽Day 22/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2022/","excerpt":"","text":"上次講到了Strong Parameters，今天我們就從Flash開始吧！ 快閃訊息flash 在按下按鈕後，應該要有個訊息出現告知使用者是否有成功或失敗，並且只出現一次，這就是快閃訊息做的事。在這個專案，我們希望如果 create 成功，會將網頁導向 首頁 並印出 “新增候選人成功!!”，反之若失敗，則印出”新增候選人失敗!!” (一樣false還沒寫入) 12345678910111213141516171819#上略 def create clean_params = params.require(:candidate).permit(:name, :age, :policy, :party) @candidate = Candidate.new(clean_params) if @candidate.save flash[:notice] = \"新增候選人成功!!\" #第7~8行可直接寫成 redirect_to root_path, notice: \"新增候選人成功!!\" redirect_to root_path else flash[:notice] = \"新增候選人失敗!!\" #第10~11行可直接寫成 redirect_to root_path, notice: \"新增候選人失敗!!\" redirect_to root_path end endend#並在index.html.erb檔加入&lt;%= flash[:notice] %&gt; 印出\"新增候選人成功!\" 首頁印出候選人列表想要在首頁做事情，那當然是去 index 做事，首先針對 candidate_controller.rb 裡的 index method寫入: 123@candidates = Candidate.all注意:這裡的實體變數故意列為\"複數\"，因為是撈出全部候選人的資料 去抓所有使用者輸入的資料。再來到 index.html.erb 利用each迴圈印出所有候選人的”姓名”。 12345678910111213&lt;%= flash[:notice] %&gt;&lt;h1&gt;首頁:候選人列表&lt;/h1&gt;# &lt;%%&gt;不顯示在頁面#&lt;=%%&gt;要顯示在頁面上&lt;ul&gt; &lt;% @candidates.each do |candidate| %&gt; #注意是@candidate\"s\" &lt;li&gt;&lt;%= candidate.name %&gt;&lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;%= link_to '新增候選人', new_candidate_path, class: 'btn btn-danger btn-lg' %&gt; 驗證資料人打字總偶爾有肥手指、眼睛業障或看錯欄位的狀況發生，所以每個輸入的資料都需要做進一步的認證才能進入資料庫。 (總不可能候選人只有3歲吧!!!?) 還記得剛剛寫的 if else 判斷總是忽略 false 的話怎麼辦對吧? 如果不寫入以下程式碼的話，永遠不會進入到 else 的判斷，到 candidate.rb 裡新增: 123456789class Candidate &lt; ApplicationRecord validates :name, presence: true #腦補眼鏡 #validates (:name, &#123;presence: true&#125;) validates :age, numericality: &#123; greater_than_or_equal_to: 40 &#125; #腦補眼鏡 #validates (:age, &#123;numericality: &#123; &#123;greater_than_or_equal_to: 40&#125; &#125;&#125;)end 姓名欄位: 有資料才會會回傳true ; 年紀欄位: 必須大於或等於40歲其實我們再 create 中的 if else 判斷式寫的較不人性化，若今天使用者打錯某字跳出”新增候選人失敗!!”，回到新增頁面後竟然還要重新打字，是不是太麻煩了? 所以我們要修正else後的輸出方式: 12345678910111213141516171819202122class CandidatesController &lt; ApplicationController def index @candidate = Candidate.all end def new @candidate = Candidate.new end def create clean_params = params.require(:candidate).permit(:name, :age, :policy, :party) @candidate = Candidate.new(clean_params) if @candidate.save flash[:notice] = \"新增候選人成功!\" redirect_to root_path else #原來寫法:flash[:notice] = \"新增候選人失敗!\" #原來寫法:redirect_to root_path render :new # 借new.html.erb這個檔案，並不是上方的new方法!!! end endend 就解決了如果打錯字回到頁面後文字被洗掉的問題。 哪裡輸入錯誤?若輸入錯誤的話，總要告訴使用者是哪裡輸入錯誤吧?new.html.erb內新增判斷式，就會印出Rails內建的full_messages資料庫訊息: 1234567891011&lt;h1&gt;新增候選人&lt;/h1&gt;&lt;% if @candidate.errors.any? %&gt; #.errors.any? =&gt;有錯誤嗎? &lt;ul&gt; &lt;% @candidate.errors.full_messages.each do |message| %&gt; # .full_messages =&gt; Rails內建的錯誤訊息資料庫 &lt;li&gt;&lt;%= message %&gt;&lt;/li&gt; &lt;% end %&gt; &lt;/ul&gt;&lt;% end %&gt;&lt;%= form_for(@candidate) do |form| %&gt;#下略.... 查看候選人詳細資料當然在看候選人的時候不可能只看名字吧?所以我們要做一個只要點選候選人姓名，就轉至候選人資料的頁面。index.html.erb頁面: 12345678910111213141516171819#index.html.erb&lt;%= flash[:notice] %&gt;&lt;h1&gt;首頁:候選人列表&lt;/h1&gt;&lt;!--&lt;ul&gt; &lt;% @candidate.each do |candidate| %&gt; &lt;li&gt;&lt;%= candidate.name %&gt;&lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt; --&gt;&lt;ul&gt; &lt;% @candidate.each do |candidate| %&gt; &lt;!--路徑需查 rails routes --&gt; &lt;li&gt;&lt;%= link_to candidate.name, candidate_path(candidate.id) %&gt;&lt;/li&gt; &lt;% end %&gt;&lt;/ul&gt;&lt;%= link_to '新增候選人', new_candidate_path, class: 'btn btn-danger btn-lg' %&gt; 就會是可以點選的狀態了，能夠預期若按下候選人姓名會發生什麼事嗎? 因為我們還沒有建立在 show 方法: 12345def show @candidate = Candidate.find_by(id: params[:id]) #Candidate.find_by =&gt; Rails內建尋找相對應資料的方法 #腦補眼鏡(&#123;id: params[:id]&#125;)end ({id: params[:id]}) :取params內key是:id的value當作外面id:的value聽起來很像繞口令，讓我們一步一步拆開來看。 params本身是Hash的資料型態，也就是上面有敘述過的一大串資料: {“utf8”=&gt;”✓”, “authenticity_token”=&gt;”0OHbZ7WkDs8NsrNHK2s7Dd9BxkITn/qegeFtUcMmE5ANKKiaxmRCOiPuChEAoKh4ho/taDYBB7GvIhTG0a1IHw==”, “candidate”=&gt;{“name”=&gt;”Louis”, “party”=&gt;”none”, “age”=&gt;”20”, “policy”=&gt;”Rails is Good”}, “commit”=&gt;”Create Candidate”, “controller”=&gt;”candidates”, “action”=&gt;”create”} 上面有講過個例子，若我要拿到Louis，我需要寫params[&#39;candidate&#39;][&#39;name&#39;] 才能拿到對吧? params[‘candidate’][‘name’] ↓ ↓ ({ id: params[:id]}) 12345假設 params = &#123; id: 5, email: 'kk@5xruby.tw', name: 'Louis' &#125;find_by(id: params[:id], email: params[:email], name: params[:name])find_by( 5 , kk@5xruby.tw , Louis )這樣可以找到在候選人表格裡「id 是 5，而且 email 是 kk@5xruby.tw，而且 name 是 Louis」的候選人 這樣對應著看，應該有比較容易理解吧!! 但還是會出現錯誤(笑 記得也要在views建立 show.html.erb 12345678910&lt;% if @candidate %&gt; &lt;h1&gt;&lt;%= @candidate.name %&gt;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;黨派: &lt;%= @candidate.party%&gt; &lt;/li&gt; &lt;li&gt;年紀: &lt;%= @candidate.age%&gt; &lt;/li&gt; &lt;li&gt;政見: &lt;%= @candidate.policy%&gt; &lt;/li&gt; &lt;/ul&gt;&lt;% else %&gt; &lt;h1&gt;沒有這個人&lt;/h1&gt;&lt;% end %&gt; 就終於完成了簡易CRUD中的C跟R… 腦細胞少10%，皺褶增加0.001%參考資料： 為你自己學Ruby on Rails “The difference in winning and losing is most often…not quitting.” — Walt Disney, Producer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day21: 簡易Rails實作(中)","slug":"2019/鐵人賽Day 21","date":"2019-10-04T04:10:40.000Z","updated":"2020-09-29T09:18:56.328Z","comments":true,"path":"2019/鐵人賽Day 21/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2021/","excerpt":"","text":"上次透過簡單首頁、分頁製作了第一個rails專案，了解到其中MVC的運作原理及routes與controller之間的關聯性，這次我們將延續上次的內容添加一些功能，並透過CRUD 中（Create、 Read、 Update、 Delete）C跟R的流程來建立專案，U和D的部分就暫時有機會的時候再說明了，現在就來做做看吧！ 新增候選人至表單在new.html.erb檔案中，我們需要一個表單讓使用者輸入，輸入後把資料丟到我們想要去的地方，先來建立表單吧! 12345678&lt;h1&gt;新增候選人&lt;/h1&gt;&lt;form action=\"/candidates\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;%= link_to '回首頁', candidates_path, class: 'btn btn-primary btn-lg'%&gt; 其中我們可以看到第3行的action指的是我們要將資料丟去哪裡，method則是丟出去的方法。 (在終端機執行rails routes) 使用者填完表單並按送出後，會將資料丟去 candidates POST / candidates(.:format) candidates#create:對candidates(.:format) 這個地方丟資料去candidates#create的時候，需要用 post 方法。此例我們要丟去的位置是create，且要用post的方式丟出，所以可以看到第3行 action=&quot;/candidate&quot; method=&quot;post&quot; 的部分才要用post而不是get。 此時的畫面長這樣: 這時候如果我們隨便輸入東西並按下提交，會出現下圖: 還記得上次的步驟嗎?我們在controller根本還沒有給他方法，那它缺什麼，我們就給他什麼吧，回到 candidates_controller.rb 接下來應該大功告成了吧~至少應該可以按下提交後不會跳出錯誤了(灑花 BUT!!!!人生就是有無限的BUT…. Rails 的預設防護 照上次的經驗來看，應該是只要新增方法就至少不會跳出錯誤了，但這裡為何會出錯呢? 原來是在rails裡面為了保護資料庫的安全，有個預設防護的機至給擋下來了。 什麼是Token? 生活情境: 小菜走在士林夜市，買了一杯位在”門口”的60嵐的珍奶並拿了20號號碼牌，想說要等，就先進去走走晃晃，看到前方剛好有一家位在”轉角”的60嵐!!!天真的小菜異想天開，想說反正都是60嵐直接拿號碼牌去領也可以吧!? 好懶得走回去喔… 跳到20號了!!! 店員: 呃(os:又來個知日 阝章)….你這個號碼牌不是我們店的喔，所以不能給你珍奶。 小菜難過的走在路上….就被端走了 token有點像在做這件事，你手上的號碼牌顯示的店面，必須要跟領取的店面相同，才能夠拿到珍奶(我們要的結果)。 12345678910&lt;h1&gt;新增候選人&lt;/h1&gt;&lt;form action=\"/candidates\" method=\"post\"&gt; &lt;input type=\"text\" name=\"username\"&gt; &lt;input type=\"hidden\" name=\"authenticity_token\" value=\"&lt;%= form_authenticity_token %&gt;\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;%= link_to '回首頁', candidates_path, class: 'btn btn-primary btn-lg'%&gt; 我們在 new.html.erb 檔案新增第5行，到開發者工具來檢視一下token: 紅色框線value的部分就是token的值，且每次重新整理都會更新一次。 這樣一來，按下提交後就不會噴錯誤訊息囉，可是不覺得每次要做個送出資料的欄位就要打這一串很麻煩嗎? 可以用上次介紹的 form_for 就可以省略複雜的那一行了，且rails會根據你在views的哪個檔案，自動幫你在button( &lt;%= form.submit %&gt;)中加入文字。(ex: Updated Candidate, Edit Candidate…) 12345&lt;%= form_for(物件) do |form| %&gt; 資料打在這裡&lt;% end %&gt; 在Model建立表單Rails有個方式可以使 form_for 表單綁在Model上，在終端機輸入: 12345rails generate model Candidate name:string party:string age:integer policy:textor 簡單一點的寫法 (預設就是string)rails g model Candidate name party age:integer policy:text 新增了兩個檔案: models下的candidates.rb 及 db&gt;migrate&gt;*********_create_candidates.rb 其中在*********_create_candidates.rb會建立name(型態:string)、party(型態:string)、age(型態:integer)、policy(型態:text)，後面的timestamp(created_at, updated_at)其實是內建的，用來紀錄提交時的時間點。 (備註: Rails在資料庫建立資料表的時候，會帶一個預設的隱藏ID的欄位，且在上面不會顯示，如果不想要ID欄位的話可以再下指令去除。) 到了這個步驟，其實並不是真正的建立表單了，我們只是告訴它，我有這個要建立表單的”計畫”，所以還需要在終端機輸入: 1rails db:migrate 才是告知”請按照這個計畫執行”。 如果此時再 rails db:migrate一次，並不會發生任何事，因為已經建立好了就辦法再更改，如果要更改已建立的檔案只有兩種方式: 建立一個新的表單並”存檔”後，再rails db:migrate一次。rails db:rollback， 但請盡量少用，除非非常確定，否則用了rollback後沒辦法再回復。 之後再開schema.rb就可以確認是否是你要的結果了。 完成表單接著在 new.html.erb 透過 form_for將表單完成後如下: 1234567891011121314151617181920212223242526272829&lt;h1&gt;新增候選人&lt;/h1&gt;&lt;%= form_for(Candidate.new) do |form| %&gt; &lt;div class=\"box\"&gt; &lt;div class=\"candidate_field\"&gt; &lt;%= form.label :name, '姓名' %&gt; &lt;%= form.text_field :name %&gt; &lt;/div&gt; &lt;div class=\"candidate_field\"&gt; &lt;%= form.label :party, '黨派' %&gt; &lt;%= form.text_field :party %&gt; &lt;/div&gt; &lt;div class=\"candidate_field\"&gt; &lt;%= form.label :age, '年紀' %&gt; &lt;%= form.text_field :age %&gt; &lt;/div&gt; &lt;div class=\"candidate_field\"&gt; &lt;%= form.label :policy, '政策' %&gt; &lt;%= form.text_area :policy %&gt; &lt;/div&gt; &lt;%= form.submit %&gt; &lt;/div&gt;&lt;% end %&gt;&lt;%= link_to '回首頁', candidates_path, class: 'btn btn-primary btn-lg'%&gt; 其中的 Candidate.new 是從Models裡的 candidate.rb 來的，但html.erb檔盡量用來做”印出內容”的事情就好，故我們不會希望在這裡用Candidate.new 來產生方法。 在 candidates_controller.rb 裡的new method建立一個實體變數 @candidate ，接著寫入至 new.html.erb 裡面取代原來的Candidate.new 。 新增候選人資料此時按下create並不會產生任何事情，因為在controller裡的create method沒有寫任何東西，寫入下列程式至create: 12345678910class CandidatesController &lt; ApplicationController def index end def new @candidate = Candidate.new end def create render html: params endend 來看看 html: params 印出的內容 {“utf8”=&gt;”✓”, “authenticity_token”=&gt;”0OHbZ7WkDs8NsrNHK2s7Dd9BxkITn/qegeFtUcMmE5ANKKiaxmRCOiPuChEAoKh4ho/taDYBB7GvIhTG0a1IHw==”, “candidate”=&gt;{“name”=&gt;”Louis”, “party”=&gt;”none”, “age”=&gt;”20”, “policy”=&gt;”Rails is Good”}, “commit”=&gt;”Create Candidate”, “controller”=&gt;”candidates”, “action”=&gt;”create”} 剛剛輸入的資料就這樣全部已hash的方式印出來了，假設我們今天要取”name”裡面的value，我們可以這樣做: 12345render html:params[\"candidate\"]印出 &#123;\"name\"=&gt;\"Louis\", \"party\"=&gt;\"\", \"age\"=&gt;\"\", \"policy\"=&gt;\"\"&#125;render html:params[\"candidate\"][\"name\"]印出 Louis 寫入資料庫create 的方法中可以用@candidate.save 來儲存使用者輸入的資料。 1234567891011121314151617class CandidatesController &lt; ApplicationController def index end def new @candidate = Candidate.new end def create #params[\"candidate\"]印出的是&#123;\"name\"=&gt;\"Louis\", \"party\"=&gt;\"\", \"age\"=&gt;\"\", \"policy\"=&gt;\"\"&#125; @candidate = Candidate.new(params[\"candidate\"]) if @candidate.save render html: 'ok' else #render html: 'error' end endend 如果儲存成功，印出ok，因為還沒寫入false的條件，故先暫時不管。 輸入資料按下create之後，就出現錯誤了….. Rails的另一個預設防護: Strong Parameters為了避免有心人士在填資料時，偷塞參數或惡搞資料庫，造成安全問題，所以在使用者輸入資料要進資料庫的同時，利用permit來過濾並設定那些資料是可以進資料庫哪些不行。 1234567891011121314151617class CandidatesController &lt; ApplicationController def index end def new @candidate = Candidate.new end def create clean_params = params.require(:candidate).permit(:name, :age, :policy, :party) @candidate = Candidate.new(clean_params) if @candidate.save render html: 'ok' else render html: 'error' end endend 12345clean_params = params.require(:candidate).permit(:name, :age, :policy, :party)params.require(:candidate) =&gt; 就是找到\"candidate\"=&gt;&#123;\"name\"=&gt;\"Louis\", \"party\"=&gt;\"none\", \"age\"=&gt;\"20\", \"policy\"=&gt;\"Rails is Good\"&#125;, \"commit\"=&gt;\"Create Candidate\", \"controller\"=&gt;\"candidates\", \"action\"=&gt;\"create\"&#125;.permit(:name, :age, :policy, :party) =&gt; 允許:name, :age, :policy, :party 輸入的參數可以進入資料庫 就可以正常執行了。(印出ok) 礙於篇幅….好像只能先講到這，我們明天再繼續了。 參考資料： 為你自己學Ruby on Rails “Flaming enthusiasm, backed up by horse sense and persistence, is the quality that most frequently makes for success.” — Dale Carnegie, Motivational Expert","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day20: 簡易Rails實作(上)","slug":"2019/鐵人賽Day 20","date":"2019-10-03T04:10:40.000Z","updated":"2020-09-29T09:18:56.294Z","comments":true,"path":"2019/鐵人賽Day 20/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2020/","excerpt":"","text":"在開始之前，要先知道用Rails的慣例，並且盡量遵守才不會造成後面要接手的人的困擾。尤其是以下說明需特別注意： 在檔案區命名：snakecase ex: candidate_controller在檔案內命名：camelcase ex: CandidateController且“檔案名稱”與“類別名稱”必須相同，才不會在執行的時候出現error 什麼是MVC(Model、View、Controller)?在開始建立Rails之前，我們需要先了解什麼是MVC MVC架構：由Route開始，到Controller結束。 瀏覽器依據資源(resources)的設定，經由Route去找到Controller中，對應的action(method)。 視需要透過Model向資料庫取得資料後，處理完再與對應的View(.html.erb)做結合。 View處理完後再回傳給Controller，Controller再將結果轉交給瀏覽器。 建立Rails專案在Terminal輸入，就會自動產生rails專案。（前提是要先安裝好Rails） 1rails new 專案名稱 在這次的例子，我們試著產生一個名叫myvote的Rails檔案。 routes.rb在Vscode開啟資料夾，用command+P尋找檔案“routes.rb”，並寫入： Rails 提供的 resources 根目錄(首頁) candidates，且裡面有個方法index 第2行：產生8種條路徑 第3行：根目錄裡有個方法index 備註： 123root 'candidates#index'get '/', to 'candidates#index'#因為是根目錄，以上兩種寫法都可以接受。 在此時在Terminal執行Rails： 1rails server 或 rails s 至網址輸入localhost:3000(Terminal會寫3000)出現以下畫面: 找不到method，故要建立一個給它。 建立Method在app &gt; controllers中新增檔案 “檔名_controller.rb” (此例檔名為candidates，需與你要連結的檔案名稱一樣)，並建立class 、繼承最原始的檔案“ApplicationController”：（其實此例的def index暫時不寫也沒關係） 但這樣還不夠，因為Rails的遊戲規則是要從views裡面找檔案，所以必須還要再 views 資料夾新增一個candidates資料夾，並建立 index.html.erb： 才能印出： 基本上這樣就完成最最最基礎的第一步了(此例index裡沒寫東西只是因為要當範例而已，請原諒我沒放東西(跪)） 讓他稍微可以動在index.html.erb加點東西： Prefix :new_cadidates 還記得剛剛的rails routes嗎？其中的new功能Rails已經有幫我們定義好的Prefix名字了 _path:產生相對應的路徑網址（站內路徑）-&gt; ／candidates *另一種方式： ＿url:產生完整網址 -&gt; https://www.xxxx.com/candidates，在寄發mail的時候較常使用) 套用Bootstrap，套用方式可見這篇。 等等！！！views裡沒有new這個檔案啊！！？所以要記得在views &gt; candidates 裡再新增一個new.html.erb檔 這樣一來就可以有作用囉!! 總結Rails這只是第一步而已，雖然現在有很多指令可以快速產出以上步驟做出的東西(scaffold)，但畢竟在使用套件之前，能夠先了解如何手刻及其背後觀念跟原理是非常重要的。 也許文章內容寫的不正確也缺乏系統，也或許幾年後回來看自己寫的這篇文章會覺得”WTF這什麼鬼!!?” 參考資料：為你自己學 Ruby on Rails “The pro is the person who has all the hassles, obstacles, and disappointing frustrations that everyone else has, yet continues to persist, does the job, and makes it look easy.” — David Cooper, Sales Trainer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day19: Rails中神奇的spring stop","slug":"2019/鐵人賽Day 19","date":"2019-10-02T04:10:40.000Z","updated":"2020-09-30T06:41:34.523Z","comments":true,"path":"2019/鐵人賽Day 19/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2019/","excerpt":"","text":"Day19: Rails中神奇的spring stop您有遇過rails g migration時卡住嗎？您有rails sever打不開的問題嗎？trivago 意外的查到的資料不多，所以這篇僅擷取Rails REARDME.md來簡單翻譯一下。 spring stop常常在跑rail時，都會遇到一些很奇怪的狀況導致migration, rails sever, rails db:seed等跑不出來這狀況，但只要下了spring stop通常就解了？ Rails在4.1版本後新增了srping stop功能，來看看rails guide寫什麼： Spring 會預加載你的 Rails 應用程式。保持應用程式在背景執行，如此一來在執行 Rails 命令時：如跑測試、rake、migrate 時，不用每次都重啟 Rails 應用程式，加速你的開發流程。 簡單來說就是應用程式預加載器，就像加速器一樣的概念。 spring stop的特性 在背景自動執行，只開啟終端機並進入rails資料夾就會自動執行 每次執行時重新載入你的rails專案中的code 當config、initializer、gem dependencies有更新時重新啟動 spring stop的運行建立一個新的Rails專案並執行rails generate scaffold post name:string 打開終端機測試一下 123456789101112131415$ time bin/rake test test/controllers/posts_controller_test.rbRunning via Spring preloader in process 2734Run options:# Running tests:.......Finished tests in 0.127245s, 55.0121 tests/s, 78.5887 assertions/s.7 tests, 10 assertions, 0 failures, 0 errors, 0 skipsreal 0m2.165suser 0m0.281ssys 0m0.066s 跑的速度不算特別快，因為是第一次執行這個專案，所以花的時間會比較長 來看一下spring的狀態： 12345$ bin/spring statusSpring is running:26150 spring server | spring-demo-app | started 3 secs ago26155 spring app | spring-demo-app | started 3 secs ago | test mode 再跑一次就可以發現速度快很多： 123456789101112131415$ time bin/rake test test/controllers/posts_controller_test.rbRunning via Spring preloader in process 8352Run options:# Running tests:.......Finished tests in 0.176896s, 39.5714 tests/s, 56.5305 assertions/s.7 tests, 10 assertions, 0 failures, 0 errors, 0 skipsreal 0m0.610suser 0m0.276ssys 0m0.059s 在coding時做的變更，會根據你在更新哪個檔案去判別是否要重新啟動後台。 舉例來說當我們修改application file或是test file時，相關的變更會再下一次執行時變更，你只需要重新刷瀏覽器，但後台系統不必重新啟動。 但當如果我們修改啟動應用程式所需的檔案，例如：configs, initializers, gemfile時，則後台需要重新啟動應用程式，而且會自動執行。 例如編輯config/application.rb： 123456$ touch config/application.rb$ bin/spring statusSpring is running:26150 spring server | spring-demo-app | started 36 secs ago26556 spring app | spring-demo-app | started 1 sec ago | test mode spring會偵測到config底下有檔案被更新後，就會自動啟動。 也許是spring的關係，所以常常會將我們不需要的東西先預載入到後台，導致我們在執行migration, rails s等會發生問題，所以才會需要下spring stop來終止預先載入的行為。 這只是我的推測…如果有錯的話歡迎指正。 參考資料： Rails/spring/REARDME.mdRuby on Rails 4.1 發佈記 “If you really want something, you have to be prepared to work very hard, take advantage of opportunity, and above all never give up.” — Jane Goodall, Ethologist","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day18: 淺談Rails的表單: form_with","slug":"2019/鐵人賽Day 18","date":"2019-10-01T04:10:40.000Z","updated":"2020-09-29T09:18:56.176Z","comments":true,"path":"2019/鐵人賽Day 18/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2018/","excerpt":"","text":"form內 有 model實體時，用form_for，主要用於新增或修改。 form內 無 model實體時，用form_tag，主要用於登入一筆資料。 Rails 5.1後，將兩者結合為form_with 上次提到了form_tag及form_for，在Rails 5.1之後結合為form_with，代表form_with結合了兩種form的特性，不論有無Model都可以使用。 使用form_with製作表格製作對象有Model時： 1234567#products_controller.rb#@product = Product.new&lt;%= form_with model: @product do |form| %&gt; &lt;%= form.text_field :title %&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; 產出的html: 1234&lt;form action=\"/products\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"&gt;&lt;input name=\"utf8\" type=\"hidden\" value=\"✓\"&gt;&lt;input type=\"hidden\" name=\"authenticity_token\" value=\"zzGYG0KNdBU0pPfzO7QDBAWUkDcPE9czey2zv21TwaXXf5T01neGV4Hp2YwZJRUJ2doDyOrnm9ZH74Ql6Ky9Mg==\"&gt; &lt;input type=\"text\" name=\"product[title]\" id=\"product_title\"&gt; &lt;input type=\"submit\" name=\"commit\" value=\"Create Product\" data-disable-with=\"Create Product\"&gt;&lt;/form&gt; 製作對象沒有Model時： 1234&lt;%= form_with url: new_product_path do |form| %&gt; &lt;%= form.text_field :title %&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; 產出的html 1234 &lt;form action=\"/products/new\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"&gt;&lt;input name=\"utf8\" type=\"hidden\" value=\"✓\"&gt;&lt;input type=\"hidden\" name=\"authenticity_token\" value=\"ZlLlHMOezGqsuZrFgovtKbph3uYPFcZuZbHyi1V6YEJ+HOnzV2Q+KBn0tLqgGvskZi9NGerhiotZc8UR0IUc1Q==\"&gt; &lt;input type=\"text\" name=\"title\" id=\"title\"&gt; &lt;input type=\"submit\" name=\"commit\" value=\"Save \" data-disable-with=\"Save \"&gt;&lt;/form&gt; 兩種方式產出的東西幾乎是相同的，因此可以得知我們只要根據專案的情況(有無Model)去設計form_with表單就好。 data-remote=”true”12345&lt;form action=\"/products/new\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"&gt;&lt;input name=\"utf8\" type=\"hidden\" value=\"✓\"&gt;&lt;input type=\"hidden\"....&lt;/form&gt; 上面兩個例子產出的html中，有一段data-remote=&quot;true&quot;是在form_tag及form_for沒有的。 有了這個屬性之後，表單會透過 Ajax 的方式提交，而不是瀏覽器平常的提交機制，若要設定不讓Ajax的方式提交，則要另訂 local: true。 1234567#products_controller.rb#@product = Product.new&lt;%= form_with model: @product, local: true do |form| %&gt; &lt;%= form.text_field :title %&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; form_with就算沒有Model的屬性也使用form_for12345678#products_controller.rb#@product = Product.new&lt;%= form_for @product do |form| %&gt; &lt;%= form.text_field :title %&gt; &lt;%= form.check_box :is_avalble %&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; form_with12345678#products_controller.rb#@product = Product.new&lt;%= form_with model: @product, local: true do |form| %&gt; &lt;%= form.text_field :title %&gt; &lt;%= form.check_box :is_avalble %&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; 產出的html: 可以看得出來，就算Product這個Model裡沒有is_avaliable的屬性，還是可以用form_with寫出統一性的指令，而這個資料可用prodcut[is_avalible]收集。 form_with在設定html時不用花括號{}form_for或for_tag若要設定html屬性，： 1&lt;%= form_for @product, html: &#123; id: “product-id”, class: “product-type &#125; do |form| %&gt; form_with則不需要再寫花括號： 1&lt;%= form_for @product, id: “product-id”, class: “product-type do |form| %&gt; 以上大概就是淺談form_with，其實form_with有很多的細節可以討論，請原諒小弟我僅提出最基本部分來討論… 參考資料： form_with — Building HTML forms in Rails 5.1ActionView::Helpers::FormHelper “There’s no great loss without some small gain.” – Laura Ingalls Wilder, Novelist","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day17:  淺談Rails的表單: form_for? form_tag? ","slug":"2019/鐵人賽Day 17","date":"2019-09-30T04:10:40.000Z","updated":"2020-09-29T09:18:56.144Z","comments":true,"path":"2019/鐵人賽Day 17/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2017/","excerpt":"","text":"在Rails中，常常會用到表單(form)將資料傳入資料庫，其中在Rails 5.1版本之前，常用的就是form_tag與form_for，我們來看看他們的分別該在何時使用： 先說結論： form內 有 model實體時，用form_for，主要用於新增或修改。 form內 無 model實體時，用form_tag，主要用於登入一筆資料。 Rails 5.1後，將兩者結合為form_with 關於form_with，有機會我再來對它做補充，這次先針對form_for及form_tag。 form_forform內有model實體時，用form_for，Rails會根據Model的屬性，自動判斷按下submit後，是要新增還是更新Model裡的資料。 翻譯蒟蒻：有媽豆的實體就用form_for 1234567#products_controller.rb#@product = Product.new&lt;%= form_for @product do |form| %&gt; &lt;%= form.text_field :title %&gt; &lt;%= form.submit %&gt;&lt;% end %&gt; html會幫你產生 1234567&lt;form class=\"new_product\" id=\"new_product\" action=\"/products\"accept-charset=\"UTF-8\" method=\"post\"&gt;&lt;input name=\"**utf8**\" type=\"hidden\" value=\"✓\"&gt;&lt;input type=\"hidden\" name=\"**authenticity_token**\" value=\"kxDHc4ID2xFAfBXANcrXBpqtI/6rerAkMBaCh64j+O6LXsucFvkpU/UxO78XW8ELRuOwAU6O/MEM1LUdK9yEeQ==\"&gt; &lt;input type=\"text\" name=\"product[title]\" id=\"product_title\"&gt; &lt;input type=\"submit\" name=\"commit\" value=\"Create Product\" data-disable-with=\"Create Product\"&gt;&lt;/form&gt; 來簡單看看上面程式碼：第一個 name 屬性為 utf8 的 input，強制瀏覽器正確採用表單指定的編碼。第二個 name 屬性為 authenticity_token 的 input，是 Rails 內建用來防止 CSRF (cross-site request forgery protection) 攻擊的安全機制。 為何要有這樣的保護機制: CSRF跨站請求偽造 Cross-site request forgery 這樣設定好整個表格，就是為了將@product這個ActiveRecord資料而設定的，所以表格送出的params會將我們在表格內填的變數，整個包在product物件下面，才會需要使用Strong Parameter那樣的機制將product變數抽出做permit(避免CSRF攻擊)： 123def product_params params.require(:product).permit(:title, :password)end form_tagform內無model實體時，用form_tag，得指定要傳入哪個連結的action來進行表單資料的傳送。 翻譯蒟蒻：沒有媽豆的時候就只能用form_tag 1234&lt;%= form_tag url:new_product_path do %&gt; &lt;%= text_field_tag :title %&gt; &lt;%= submit_tag %&gt;&lt;% end %&gt; 1234567&lt;form action=\"/products/new?url=%2Fproducts\" accept-charset=\"UTF-8\"method=\"post\"&gt;&lt;input name=\"utf8\" type=\"hidden\" value=\"✓\"&gt;&lt;input type=\"hidden\" name=\"authenticity_token\" value=\"lfORCE9tuYA4Yuda6EziGwKMQk9flV9dkM4ogaEzmUCNvZ3n25dLwo0vySXK3fQW3sLRsLphE7isDB8bJMzl1w==\"&gt; &lt;input type=\"text\" name=\"title\" id=\"title\"&gt; &lt;input type=\"submit\" name=\"commit\" value=\"Save changes\" data-disable-with=\"Save changes\"&gt;&lt;/form&gt; 如果是使用form_tag，變數就不會包在任何東西內，可以直接在controller當中取用： 123def search @products = Product.where(product: params[:search])end 參考資料： Ruby API: form_tagRuby API: form_forRails 5.1’s form_with vs. form_tag vs. form_for form_tag 是啥？跟 form_for 有什麼不一樣？ “A man can get discouraged many times, but he is not a failure until he begins to blame somebody else and stops trying.” — John Burroughs, Writer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day16: 淺談Rails裡的resources","slug":"2019/鐵人賽Day 16","date":"2019-09-29T04:10:40.000Z","updated":"2020-09-29T09:18:56.112Z","comments":true,"path":"2019/鐵人賽Day 16/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2016/","excerpt":"","text":"resources:可以一次新8條路徑，7個方法，當然也可以一條一條自己新增(get, post)，但若剛好你要做的專案需要這8條路徑的話，用這種內建方式做可以省去不少時間且也會更有系統。 如果resources後面沒加s，在路徑的部分會有些action就不需要帶id，但會少一個路徑。 resource resources RESTful 的網址設計：導入 REST 的設計，可讓網址變得更直觀，而且也幫開發人員訂了一套網址設計的慣例。 在Terminal裡輸入： 1rails routes 青藍色框：Prefix要的名稱黃色框：網址後會產生的path紅色框：路由 或是可以去網址打localhost:3000/這邊可以亂打 也可以看到路徑(我很懶..幾乎都用這個方式在查) 可以一個指令產生這麼多東西！！！真的很方便，但如果剛好你不需要某些路由想要去除的話，可以用以下方式： 12345resources :candidates, only: [:new, :show] -&gt; 只要路由new跟show或resources :candidates, except: [:new] -&gt;8個都要除了路由new 根據你要其中的幾個路由去決定要用only還是expect，若要較少的時候用only較適合，反之要多的路由就用expect。 抱歉這次文章品質實在很差… 我是在跟未來的自己抱歉 反正…… 又沒人會看(誤 “A hero is an ordinary individual who finds the strength to persevere and endure in spite of overwhelming obstacles.” — Christopher Reeve, Actor","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day15: Rails中的Gemfile","slug":"2019/鐵人賽Day 15","date":"2019-09-28T04:10:40.000Z","updated":"2020-09-29T09:18:56.080Z","comments":true,"path":"2019/鐵人賽Day 15/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2015/","excerpt":"","text":"在Ruby的宇宙裡，有很多用Ruby寫成的套件包或是框架可以使用，包含rails也是(第6行)。 Gemfile是Rails new一個新專案時附加的檔案(如上圖rails 5.2.3)，主要管理此Rails專案該會使用哪些gem檔案及版本號，在跑bundle install時就會安裝到這個專案，所以可以視為紀錄這個專案該使用哪些gem的檔案，讓專案被其他使用者pull下來時，都能根據Gemfile裡的gem去安裝。 裡面怎麼那麼多東西？讓我們來稍微檢視一下，預設的Gemfile到底有哪些東西，分別是做什麼用的？(抱歉可能沒辦法一個一個檢視…) 告訴Rails該去哪裡抓Gem下來用，預設為 rubygems.org 1source &quot;https://rubygems.org” 還會再多設置一個GitHub的URL當做備用來源 1git_source(:github) &#123; |repo| &quot;https://github.com/#&#123;repo&#125;.git” &#125; 版本號在ruby gem常常會看到後面接”數字.數字.數字“，可以解讀為：“#{major}.#{minor}.#{build}” 主要版號(major)：功能大改，公開的 API 做了不少修正，通常沒辦法向下不相容次要版號(minor)：加了某些新功能，但不影響其它功能，向下相容修訂版號(build)：對現有的功能做了小幅度的修正，可向下相容 by Ruby 語法放大鏡 像最近rails從5.2.3更新為6.0.0，就是很大改版，就要相對注意相容性的問題。 gem的版本號可以看到有些gem的後面有加~&gt; 3.2.1 &gt;=或沒加等等這幾種： gem後沒加：安裝最新的”穩定”版本 1gem &apos;kaminari&apos; ‘ ‘：指定版本 1gem &quot;rails&quot;, &apos;5.2.3&apos; “&gt;=, &lt;：安裝含1.1版本以上 ~ 不包含1.1.4版本。 1gem &apos;pg&apos;, &apos;&gt;= 1.1&apos;, &apos;&lt; 1.1.4&apos; ~&gt;：算是縮寫，使用1.9版本以上，但2.0以下(不包括2.0)的最新版本 12345gem &apos;omniauth&apos;, &apos;~&gt; 1.9&apos;#等同於gem &apos;omniauth&apos;, &apos;&gt;= 1.9&apos;, &apos;&lt; 2.0&apos; Gemfile的Grop大約分為三種，Product（上線/發佈）, Development（開發）, Test（測試）。 Product 上線 / 發佈： 123gem &apos;rails&apos;, &apos;~&gt; 5.2.3&apos;沒有在grop裡代表上線/發佈時才會使用到 Development（開發） 1234group :development doend寫在Development，這裡的 gem 會在開發時使用，上線時不會用 Test (測試） 1234group :test doend寫在Test裡，這裡的 gem 會在開發時使用，上線時不會用 Development, Test（開發,測試） 1234group :development, :test doend寫在Development裡, Test，這裡的 gem 會在開發及測試時使用，上線時不會用 參考資料：What is a Gemfile?Ruby 語法放大鏡 “If you’re walking down the right path and you’re willing to keep walking, eventually you’ll make progress.” — Barack Obama, the 44th U.S. President","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day14: 淺談Model資料表關聯","slug":"2019/鐵人賽Day 14","date":"2019-09-27T04:10:40.000Z","updated":"2020-09-29T09:18:56.050Z","comments":true,"path":"2019/鐵人賽Day 14/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2014/","excerpt":"","text":"不管用哪個程式語言或框架寫網站，多數會有資料庫的應用，資料與資料之間一定會有關聯性，那要如何在不同Model設立資料關係，這裏會用很簡單的例子去試著理解什麼是資料表關聯。 Active Record根據手冊：「Active Record 是 MVC 的 M（Model），表現商業邏輯與資料的層級，負責新增與操作需要持久存在資料庫裡的資料」 看起來有點抽象，在我的理解大概就是這個概念： Active Record ＝ 把資料做成物件（是一種ORM框架）物件 = 欄位 + 基本操作 + 商業邏輯 這樣寫似乎還是有點抽象，但其實可以想像成： 1Model = ActiveRecord.new 用店面舉例先預設我們有3個Model: Owner Stroe Product 1o1 = Owner.create(name: &apos;Louis&apos;) 12s1 = Store.new(title: &apos;Louis Shop&apos;)此時s1的owner_id還是空的 123o1.store = s1把 Store 指定給 Owners1的Owner_id就有3了 可用 create (本身包含.save)12o1 = Owner.create(name: &apos;Sherly&apos;)o1.create_store(title: &apos;Ruby Shop&apos;) 用build(本身不包含save)還未.save前，可看到shop的id是空的 .save後 用new不會存進資料庫，必須額外.save 用另一個角度只要有任一方有存入資料庫，就可以設定關聯性，不須雙方都存入資料庫 12.create_store =&gt; 直接寫入資料庫.build_store =&gt; 建立，但未寫入資料庫 has_one:store，產生以下四個方法:12345(類似 Cat = Animail.new的概念)•store•store=•build_store•create_store belongs_to1234belongs_to 也是一個類別方法執行belongs_to :owner，只有產生以下兩個方法:•owner•owner= has_many:products，只有產生以下四個方法:1234productsproducts=buildcreate 12345678910#個別建立物件s1 = Store.firstp1 = Product.new(name: &apos;iphone&apos;)p2 = Product.new(name: &apos;ipad&apos;)#方法一:可以一次塞入多個到s1s1.products = [p1, p2]#方法二:只能塞一個到s1s1.products.create(name: &apos;Mac&apos;) has_many: through 多對多跟has_many用起來差不多需要第三方資料表來儲存兩邊資訊第三方資料表通常只存放兩邊id，並且belong_to兩邊的Model 12345rails g WareHouse sotre:references product:references或rails g WareHouse sotre_id:integer product_id:integer 12345678910111213#store.rbclass Store &lt; ApplicationRecord has_many :ware_houses has_many :products, through: :ware_houses #透過第三方end#product.rbclass Product &lt; ApplicationRecord # belongs_to :store has_many :ware_houses has_many :stores, through: :ware_houses #透過第三方end 12345s1 = Store.firsts2 = Store.secondp1 = Product.firstp2 = Product.secondp3 = Product.third 試著建立這樣的關係： 1234下圖:p2.stores -&gt;p2商品再哪間店有貨s1.owner -&gt;s1店面的店長是誰s2.products -&gt; s2店面有哪些商品 參考資料：Model 基本操作 “I realized early on that success was tied to not giving up. Most people in this business gave up and went on to other things. If you simply didn’t give up, you would outlast the people who came in on the bus with you.” — Harrison Ford, Actor","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day13: Ruby on Rails 的 .nil? .empty? .blank? .present? ","slug":"2019/鐵人賽Day 13","date":"2019-09-26T04:10:40.000Z","updated":"2020-09-29T09:18:56.020Z","comments":true,"path":"2019/鐵人賽Day 13/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2013/","excerpt":"","text":"在Ruby on Rails有很多神奇又好用的黑魔法，但有幾個類似的方法會搞不清楚到底在哪個狀況時要用哪個method… 我在寫rails的時候曾經踩過一個小雷： 現在這個使用者的name欄位是空的，所以回傳的是nil，如果此時在current_user.name後接的是.empty?就會噴錯，所以要用.nil? 1234if current_user.name.nil? #原本寫的是.empty? redirect_to edit_user_registration_pathelse#下略 Ruby - .nil? .empty?.nil?還記得有句快說到爛的話，「在Ruby幾乎所有東西都是物件，除了block」，所以nil也是物件。 1234567891011121314151617nil.class=&gt; NilClassnil.nil?=&gt; truea = nila.nil? = true\"\".nil?=&gt; falsefalse.nil?=&gt; false[].nil?=&gt; false 可以很簡單地看出結果，只要.nil?之前接的物件是nil的話會回傳true，其他則都會回傳flase。 .empty?.empty方法前面是針對string array hash使用，如果這三種物件的長度為0 (legth == 0)的話，就會回傳true否則回傳flase。 另一種情況，如果.empty?前接的不是這三種物件的話，則會噴undefined method empty?。 123456789101112131415161718\"\".empty?=&gt; true[].empty?=&gt; true[ ].empty?=&gt; true\" \".empty? #空白字串也有長度=&gt; falsenil.empty?NoMethodError: undefined method `empty?' for nil:NilClassfalse.empty?NoMethodError: undefined method `empty?' for false:FalseClass Rails - .blank? .present?.blank?.blank?是一個ActiveRecord method，針對 nil string array hash 使用，在 false nil empty或空白字串(不是length == 0)時會回傳 true，否則回傳false。 1234567891011121314151617false.blank?=&gt; truenil.blank?=&gt; true\"\".blank?=&gt; true\" \".blank?=&gt; true #(跟.empty?不同)[].blank?=&gt; true&#123;&#125;.blank?=&gt; true .present?.present?來自·Active Record，其實就是.blank?的相反用法，換句話說就是： 1!object.blank? == object.present? 參考資料：Rails I18n 多語系How to use .nil? .empty? .blank? .present? in Rails 5.nil? .empty? .blank? .present? 傻傻分不清楚？Ruby API “The two most powerful warriors are patience and time.” — Leo Tolstoy, Novelist","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day12: Ruby的例外處理(Exceptions)：begin...rescue ...end","slug":"2019/鐵人賽Day 12","date":"2019-09-25T04:10:40.000Z","updated":"2020-09-29T09:18:55.986Z","comments":true,"path":"2019/鐵人賽Day 12/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2012/","excerpt":"","text":"幾乎每個程式語言都有例外處理的功能，當程式在執行時，不免都會遇到非工程師預期的狀況發生，我們可以針對不同例外訊息設計不同的例外處理。 在Ruby例外處理的基本架構： 12345begin #程式碼正常執行的地方 (可能出現例外的程式碼)rescue #發生錯誤時執行的地方end 當Ruby執行程式發生錯誤時，會丟出一個Error類別產生的例外物件並停止程式，各種錯誤類型用架構的方式歸納： 圖片來源:Programming Ruby book 有這麼多例外訊息的類別，要舉例可能舉不完，不過用起來大概像下面這種感覺： 123456789begin # 可能出現例外的程式碼rescue SyntaxError # 出現SyntaxError時執行此行程式碼rescue ArgumentError # 出現ArgumentError時執行此行程式碼rescue RuntimeError # 出現RuntimeError時執行此行程式碼end 所以可針對丟出的例外訊息，去處理該訊息的例外處理，當然最常見的還是SyntaxError, ArgumentError及RuntimeError。如果沒有在rescue後特別寫哪種類別的話，任何的錯誤類別都會被rescue給抓到。 在舉例之前，我想先說說該如何用raise來產生例外處理。 raise一般在簡單的程式碼，比較不會有例外處理的狀況發生，但為了舉例，我們也可以透過手動產生例外處理來觸發我們想要的結果，那我們就可以用raise method來執行。 raise是什麼？ The raise method is from the Kernel module. By default, raise creates an exception of the RuntimeError class. raise是來自於Kernel這個module的method，”預設”會產生來自RuntimeError這個類別的exception實體。 既然是預設，代表我們一定可以自己寫raise method後會產生哪個類別的實體。 預設：RuntimeError123456def raise_exception puts '這邊是執行到raise之前' raise '發生錯誤！' puts '這邊是執行到raise之後'endraise_exception 印出 12345這邊是執行到raise之前Traceback (most recent call last): 1: from test.rb:18:in `&lt;main&gt;&apos;test.rb:15:in `raise_exception&apos;: 發生錯誤！ (RuntimeError) #預設類別 指定其他類別(以ArgumentError為例)123456def raise_exception puts '這邊是執行到raise之前' raise ArgumentError, '發生錯誤！' puts '這邊是執行到raise之後'endraise_exception 印出 12345這邊是執行到raise之前Traceback (most recent call last): 1: from test.rb:18:in `&lt;main&gt;&apos;test.rb:15:in `raise_exception&apos;: 發生錯誤！ (ArgumentError) #被指定類別 begin…rescue…end預設Exception程式執行時先印出”發生例外之前”，之後遇到raise發生例外，故去找rescue底下的程式碼並執行，印出”已處理例外”。 12345678910111213def raise_exception begin puts '發生例外之前' raise '發生例外！' #沒指定Error類別，預設為RuntimeError puts '發生例外之後' rescue #預設RuntimeError，所有錯誤都會到這執行 puts '已處理例外' endendraise_exception# =&gt; 發生例外之前# 已處理例外 指定錯誤類別程式執行時先印出”發生例外之前”，之後遇到raiseLoadError類別發生例外，因為已被指定是遇到LoadError產生的實體，rescue後並無指定要救援哪個類別，故印出”發生例外！ (LoadError)”。 12345678910111213def raise_exception begin puts '發生例外之前' raise LoadError, '發生例外！' puts '發生例外之後' rescue puts '已處理例外' endendraise_exception# =&gt; 發生例外之前# 發生例外！ (LoadError) 若要修正，只要將rescue後加入該發生例外訊息時的類別就可以了。 12345678910111213def raise_exception begin puts '發生例外之前' raise LoadError, '發生例外！' puts '發生例外之後' rescue LoadError puts '已處理例外' endendraise_exception# =&gt; 發生例外之前# 已處理例外 其實以上範例的begin跟end，可以被同時省略，只要留下rescue就可以正常執行，讓程式碼看起來更精簡，但對於金魚腦的我來說，為了方便未來能夠容易閱(理)讀(解)，還是不會把它們省略。 1234567891011def raise_exception puts '發生例外之前' raise LoadError, '發生例外！' puts '發生例外之後' rescue LoadError puts '已處理例外'endraise_exception# =&gt; 發生例外之前# 已處理例外 總結：其實這個主題可以寫出非常多東西，目前只針對自己可能會用到的部分做說明，如果有興趣的朋友可以到參考資料看更多關於Exceptions的介紹。 begin...rescue...end用來解決非預期的結果。 begin…rescue: 可能發生例外的程式碼 rescue…end: 發生錯誤時執行的程式碼 可針對丟出的例外訊息，去處理該訊息的例外處理。 begin end可省略 參考資料：Ruby KernelRuby Exceptions例外處理 Rescue Exception, Error Handling, Custom Error Pages[Ruby] Error Handling（錯誤處理)Ruby 的例外處理機制Rails的錯誤處理機制begin、rescue和Exception “The meaning of life is to find your gift. The purpose &gt;of life is to give it away.” – Pablo Picasso, Artist","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day11: Ruby中的Getter及Setter?","slug":"2019/鐵人賽Day 11","date":"2019-09-24T04:10:40.000Z","updated":"2020-09-29T09:18:55.954Z","comments":true,"path":"2019/鐵人賽Day 11/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2011/","excerpt":"","text":"在最近的練習中，只有印象自己大量的在用attr_reader :somthing，在完成這篇文章前，我完全不知道其實它就是getter method… 關於setter就真的更陌生了，也有在專案或練習的時候有用到，但也一樣完全不知道其實在用的就是setter method，所以決定寫個一篇文章來釐清一下觀念。 Ruby沒有「屬性(property/attribute)」Ruby沒有屬性這件事，跟其他程式語言不一樣，下面的例子： 1234567my.event#其實原型是my.event()my.event = \"something\"#其實原型是my.event=(\"something\") my.event看起來像是在my上讀取event的屬性，但它實際是執行了my.event()方法，只是括號可以適時省略，相同的my.event=(“something”)也是同樣道理。 什麼是getter method?就英文直翻getter method是「取得(get)的方法」的意思，在Ruby裡指的就是取出實體變數(instance variable)的方法。 如果class裡沒有getter method，就無法取出在class內實體變數的值。 12345678class Favorite def initialize(event) @event = event endendmy = Favorite.new('Badminton')puts my.event 會印出錯誤訊息 1undefined local variable or method `badminton&apos; for main:Object (NameError) 可以看得出來，my這個實體拿不到class裡的實體變數@event，如果要拿到@event的話，必須給它一個getter method。 123456789101112class Favorite def initialize(event) @event = event end def event #getter method @event endendmy = Favorite.new('Badminton')puts my.event # =&gt; Badminton 龍哥說，工程師都很懶惰，如果每次要取實體變數的值都要寫一次getter method不是很麻煩嗎？ attr_reader1234567891011121314class Favorite attr_reader :event def initialize(event) @event = event end # def event #getter method # @event # endendmy = Favorite.new 'Badminton'puts my.event 在class內加入attr_reader :event就自動幫你產生寫了第8~10行。 什麼是setter method?就英文直翻setter method是「指派(assign)的方法」的意思，在Ruby裡指的就是指派實體變數(instance variable)的方法。 如果class裡沒有setter method，就無法派在class內實體變數的值。 123456789101112131415class Favorite attr_reader :event def initialize(event) @event = event end # def event #getter method # @event # endendmy = Favorite.new('Badminton')puts my.event # =&gt; Badmintonputs my.event = \"Pasta\" 會印出錯誤訊息 1undefined local variable or method `badminton&apos; for main:Object (NameError) 可以看得出來，my這個實體做event方法時，如果要直接指派event方法內部的實體變數@event為”Pasta”，必須給它一個setter method。 12345678910111213141516171819class Favorite attr_reader :event def initialize(event) @event = event end # def event #getter method # @event # end def event= food #setter method @event = food endendmy = Favorite.new('Badminton')puts my.event # =&gt; Badmintonputs my.event=(\"Pasta\") # =&gt; Pasta 等等….為什麼方法名稱有個等於又帶括號？ Ruby魔法糖? - 括號可適時的省略Rub6定義方法時，等號跟其他字元都可以當作是名字的一部分，只是規定上必須放在最後面。 所以可以將event=(food)解讀一下：event= 是方法名稱，帶有參數food 1234567event=(food)#括號可適時的省略event=food#可適時加入空白字元event = food 12345678910111213141516171819class Favorite attr_reader :event def initialize(event) @event = event end # def event #getter method # @event # end def event= food #括號可適時的省略 #setter method @event = food endendmy = Favorite.new('Badminton')puts my.event # =&gt; Badmintonputs my.event = \"Pasta\" # =&gt; Pasta #括號可適時的省略並加入空白字元 還好工程師都很懶惰再一次，這裏也可以寫成attr的方式。 attr_writer1234567891011121314151617181920class Favorite attr_reader :event attr_writer :event def initialize(event) @event = event end # def event #getter method # @event # end # def event= food #setter method # @event = food # endendmy = Favorite.new('Badminton')puts my.event # =&gt; Badmintonputs my.event = \"Pasta\" # =&gt; Pasta 在class內加入attr_writer :event就自動幫你產生寫了第13~15行。 還好偉大的懶惰工程師們，覺得如果要再多個實體變數的話，就得要再寫attr_reader跟attr_writer的方式來取得跟指派，實在太麻煩了… attr_accessor1234567891011121314151617181920212223242526class Favorite # attr_reader :event # attr_writer :event # attr_reader :price # attr_writer :price attr_accessor :event, :price def initialize(event, price) @event = event @price = price end # def event #getter method # @event # end # def event= food #setter method # @event = food # endendmy = Favorite.new('Badminton', \"$200\")my.event = \"Volleyball\"my.price = \"$300\"puts my.event # =&gt; Volleyballputs my.price # =&gt; $300 在class內加入attr_accessor :event, :price就自動幫你產生寫了第2~5行。 這也是為何我們在rails專案裡，可以用點的方式取值的概念，例如：第5~10行，在rails裡的Active Record(MVC的M (Model))，會自動建立attr_accessor :foods。 123456789101112&lt;% @foods.each do |food| %&gt; &lt;ul&gt; &lt;li&gt; 名稱：&lt;%= food.title%&gt; 數量：&lt;%= food.quantity%&gt; 可領取時間：&lt;%= food.pickup_time%&gt; 原價：&lt;%= food.origin_price%&gt; 救援價：&lt;%= food.discount_price%&gt; 描述：&lt;%= food.description%&gt; &lt;/li&gt; &lt;/ul&gt;&lt;%end%&gt; 總結 getter method: 取出實體變數(instance variable)的方法。 setter method: 指派實體變數(instance variable)的方法。 attr_reader + attr_writer = attr_accessor 參考資料：How getter/setter methods work in RubyRuby Getters and SettersRuby 語法放大鏡之「attr_accessor 是幹嘛的? “The conditions of conquest are always easy. We have but to toil awhile, endure awhile, believe always, and never turn back.” — Lucius Annaeus Seneca, Philosopher","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day10: Ruby中的Conditional Assignment Operator: x ||= y(or-equals)","slug":"2019/鐵人賽Day 10","date":"2019-09-23T04:10:40.000Z","updated":"2020-09-29T09:18:55.920Z","comments":true,"path":"2019/鐵人賽Day 10/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%2010/","excerpt":"","text":"最近的rails專案裡，看到了這行： 1@cart = @cart || Cart.from_hash(session[:cart9527]) 剛開始真的看不懂這段到底在幹嘛，為了想釐清觀念就查了一下資料，結果越查越多….而且方向還越來越偏XD 至於為什麼要特別寫這篇呢？我們已經知道Ruby中的等於是指派(Assign)的意思，那不就跟x += 1 等同於 x = x + 1而已嗎？ 圖片來源 x ||= y 不是 x = x || y難道這就是傳說中的Ruby界的WTF moment嗎？ 那 x ||= y到底是什麼？ 1234x ||= y#expansion應該長x || x = y If x is not initialized, false, nil or undefined, then evaluate y and set a to the result. 如果x尚未被初始化、false或nil及undefined，x 等於 y(換句話說:y會指派給x)，其他情況下，x值不變。 所以: 12345@cart = @cart || Cart.from_hash(session[:cart9527])#跟下面程式碼不相同@cart ||= Cart.from_hash(session[:cart9527]) @cart現在是nil，第一圈會找Cart.from_hash(session[:cart9527])指派給@cart，第二圈因為@cart已經有值，故會將值指向自己。 再來看看幾個例子： x被指派為nil或false1234x = nil # 或 x = falsey = 10puts x ||= y # =&gt; x原本是nil，印出 x = 10 x被指派為2123456x = 2y = 10puts x ||= y # =&gt; x原本是2，印出 x = 2puts x || x = y # =&gt; 2puts x = x || y # =&gt; 2 剛剛才說，”x ||= y 不是 x = x || y“，那上面例子的第6行怎麼還會印出2? 竟然是曾經的熱門議題？這個議題在約10年前討(爭)論(辯)的非常熱烈，可看下圖有人將所有的討論串做整理，最多有500多人在討論，有興趣的朋友可以點進去連結看看在吵些什麼XD 最噁心的討論就像這樣： 12345678910111213141516171819202122232425262728#sample1a ||= b#sample2a || a = b#sample3a ? a : a = b#sample4if a then aelse a = bend#sample5a = a || b#sample6a = a ? a : b#sample7if a then a = aelse a = bend a || a = b, a ? a : a = b, if a then a else a = b end, and if a then a = a else a = b end will throw an error if a is undefined, whereas a ||= b and a = a || b will not. Also, a || a = b, a ? a : a = b, if a then a else a = b end, a = a ? a : b, and if a then a = a else a = b end evaluate a twice when a is truthy, whereas a ||= b and a = a || b do not. 看得我頭都暈了…且已經超過我能理解的範圍 總結：x ||= yIf x is not initialized (or if it is set to nil or false), set it with the value of y.如果x尚未被初始化、false或nil及undefined，則 x 等於 y (換句話說:y會指派給x)，其他情況下，x值不變。 參考資料：Conditional Assignment Operator in Ruby Please explain nuances of ||=What does ||= (or-equals) mean in Ruby?The definitive list of ||= (OR Equal) threads and pagesDifference between a = a || b and a ||= bAssignmentsA short-circuit (||=) edge case超級經典面試題: Ruby的 a ||= b (or-equals)是什麼意思呢? “The man who can drive himself further once the effort gets painful is the man who will win.” — Roger Bannister, Runner","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day9: Ruby的三種存取控制Public, Private, Protected","slug":"2019/鐵人賽Day 9","date":"2019-09-22T04:10:40.000Z","updated":"2020-09-29T09:18:55.885Z","comments":true,"path":"2019/鐵人賽Day 9/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%209/","excerpt":"","text":"圖片來源 前面有提過，Ruby是一門相當徹底的物件導向語言，幾乎所有的東西都是物件，但block除外。要改變物件的狀態，在ruby最常見的方式就是.method，要拿這個method來用，就要從class內來存取，這個行為就是「存取控制」。 物件（object） = 狀態（state） + 行為（behavior) 來看最簡單的例子： 12345678class Disney def feel puts \"I feel very happy\" endendyou = Disney.newyou.feel # =&gt; I feel very happy you.feel這個東西看起來沒什麼特別，但在Ruby的解讀，會像有一個you物件，對它發送了一個「訊息」（message）feel，而這個you就是訊息的「接收者」（receiver）。 一般來說，public的存取是Ruby已預設好的。就像上面例子，如果在方法上面沒有特別寫是哪種存取方式的話，那就是會是預設的public。 用程式碼來看看三種控制： 1234567891011121314151617181920class Disney def feel puts \"I feel very happy\" end private def eat puts \"I wanna have some popcorn\" end protected def watch puts \"I wanna watch the show\" endendyou = Disney.newyou.feel # =&gt; I feel very happyyou.eat # =&gt; NoMethodErroryou.watch # =&gt; NoMethodError 另一種存取控制的寫法，寫在定義之後： 123456789101112131415161718192021class Disney def feel puts \"I feel very happy\" end def eat puts \"I wanna have some popcorn\" end def watch puts \"I wanna watch the show\" end protected :eat private :watchendyou = Disney.newyou.feel # =&gt; I feel very happyyou.eat # =&gt; NoMethodErroryou.watch # =&gt; NoMethodError 至於兩種寫法其實並沒有差別，我自己是比較偏向第一種方式，因為第二種感覺比較容易跟rails搞混，例如： 1has_many :users Private在各個程式語言都有存取控制的設計，private在其他語言被定義為「只有在類別內部才能被存取」，但在Ruby這裡的定義有點不太一樣： 不能在外部呼叫，也不能明確的指出「接收者」（receiver） 翻譯蒟蒻：若要呼叫private的方法時，前面不可以加小數點。(備註：外部的定義不包含繼承的子類別) 上面例子因為eat方法是private method，所以向you(receiver)發送eat訊息(message)會出現NoMethodError。 但private真的那麼private嗎？如果定義上不能在receiver前加小數點，那我改成其他形式總行吧？ 123you = Disney.newyou.feel # =&gt; I feel very happyyou.send(:eat) # =&gt; I wanna have some popcorn send是Ruby內建的方法，這邊只是把:eat當作參數送給you而已，指出接收者的是send方法而不是private method的eat，並沒有違反”不能明確的指出「接收者」的規定”，所以這也是Ruby跟其他程式語言在private定義不同的地方。 Protected1234567891011121314151617181920212223242526272829class Disney def feel puts \"I feel very happy\" end private def eat puts \"I wanna have some popcorn\" end protected def watch puts \"I wanna watch the show\" endendclass Marvel &lt; Disney def marvel_watch watch end def marvel_self_watch self.watch endendiron = Marvel.newiron.marvel_watch # =&gt; I wanna watch the showiron.marvel_self_watch # =&gt; I wanna watch the show 以繼承的類別Marvel來看，在父類別的protected method，不管用的是watch或self.watch都可以順利印出來。 不能在外部呼叫，但可以明確的指出「接收者」（receiver） 那如果改用private method呢？ 1234567891011121314151617181920212223242526272829class Disney def feel puts \"I feel very happy\" end private def eat puts \"I wanna have some popcorn\" end protected def watch puts \"I wanna watch the show\" endendclass Marvel &lt; Disney def marvel_eat eat end def marvel_self_eat self.eat endendiron = Marvel.newiron.marvel_eat # =&gt; I wanna have some popcorniron.marvel_self_eat # =&gt; NoMethodError 最後一行會印出錯誤，是因為private method不能明確的指出「接收者」。 總結 三種方法都可以在類別內部呼叫。 private：不能在外部呼叫，也不能明確的指出「接收者」（receiver）。 protected：不能在外部呼叫，但可以明確的指出「接收者」（receiver）。 參考資料：Ruby Access Control Basics: Public vs Private vs Protected methodsRuby Access Control類別（Class）與模組（Module）Ruby三種存取限制: Public, Protected, PrivateRuby: public, protected 與 private “Success is falling nine times and getting up ten.” — Jon Bon Jovi, Musician","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day8: Module的引入include和extend","slug":"2019/鐵人賽Day 8","date":"2019-09-21T04:10:40.000Z","updated":"2020-09-29T09:18:55.855Z","comments":true,"path":"2019/鐵人賽Day 8/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%208/","excerpt":"","text":"上次提到了類別(class)與模組(module)的差異，今天針對module如何引入進class使用來特別說明。 比較 模組(module) 類別(class) 繼承inheritance ✕ ✔ 可實體化instantiation ✕ ✔ include 加入模組進入類別使用的時候，一般最常見的就是include，延續之前的例子： 12345678910111213141516module VolleyTeam def set puts '舉球' endendclass BasketTeam include VolleyTeam #將module include到類別裡 def pass puts '接球後，傳球!' endendsakuragi = BasketTeam.new #產生sakaragi實體sakuragi.pass # =&gt; 接球後，傳球!sakuragi.set # =&gt; 舉球! #module的實體方法 當一個 class 使用 include 引入 Module 的時候，會將module內的方法在class內增加一個實體方法。 extend如果使用extend加入module模組的話： 12345678910111213141516module VolleyTeam def set puts '舉球' endendclass BasketTeam extend VolleyTeam def pass puts '接球後，傳球!' endendsakuragi = BasketTeam.newsakuragi.pass # =&gt; 接球後，傳球!sakuragi.set # =&gt; 舉球! 會出現error 1undefined method `set' for #&lt;BasketTeam:0x00007fc18783eca8&gt; 原因是如果用extend的話，會將module內的方法在class增加為類別方法，所以用實體後面去接類別方法，就會出現錯誤。 因此直接改為類別直接接類別方法就好： 123sakuragi = BasketTeam.newsakuragi.pass # =&gt; 接球後，傳球!BasketTeam.set # =&gt; 舉球! #module的類別方法，直接接BasketTeam類別 總結 Include is for adding methods to an instance of a class and extend is for adding class methods. 使用include引入，會將module內的方法在class增加為實體方法。使用extend 引入，會將module內的方法在class增加為類別方法。 參考資料：What is the different between &lt;&gt; and &lt;&gt; in use case diagram?https://medium.com/@leo_hetsch/ruby-modules-include-vs-prepend-vs-extend-f09837a5b073Include vs Extend in RubyRuby 的繼承鍊 (2) - Module 的 include、prepend 和 extend “Ninety percent of all those who fail are not actually defeated. They simply quit.” — Paul J. Meyer, Motivational Coach","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day7: Ruby裡的self是什麼？","slug":"2019/鐵人賽Day 7","date":"2019-09-20T04:10:40.000Z","updated":"2020-09-29T09:18:55.824Z","comments":true,"path":"2019/鐵人賽Day 7/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%207/","excerpt":"","text":"之前的文章有提過一句話「在Ruby裡，幾乎所有的東西都是物件」，這是否也代表每一行我們所打的code是否都屬於物件呢？ self在Ruby是一個非常特別的存在，且永遠指向目前正在執行的物件，換句話說，就是self會根據現在放在哪個context(class、method..)的不同，指的當下就是物件自己。 這樣描述還是很模糊的感覺，下面會用幾個例子去理解self放在不同context的時候，會長什麼樣子。 Top Level Context123456789name = \"Louis\"puts \"Name is: #&#123;name&#125;\"puts \"Self is: #&#123;self&#125;\"puts \"Self class is: #&#123;self.class&#125;\"# =&gt;# Name is: Louis# Self is: main# Self class is: Object 這裡可以看到self是個main物件，且main物件是類別Object下的實體，如果用程式碼寫： 123456class Object def reflect endendmain = Object.new #main大概是這種感覺 self在實體方法(instance method)與類別方法(class method)12345678910111213141516class Louis def say puts self end def self.say puts self endend#實體方法kk = Louis.newkk.say # =&gt; 此時的self為Louis class所產生的實體 &lt;Louis:0x00007fad048259e8&gt;#類別方法Louis.say # =&gt; 此時的self為Louis class本身 類別定義(class definition)12345class Louis puts \"Self is: #&#123;self&#125;\"end# =&gt; Self is: Louis 此時的self為Louis class本身 =&gt; Louis 模組定義(Module definition)12345module Group puts \"Self inside Group is: #&#123;self&#125;\"end# =&gt; Self inside Group is: Group 此時的self為module Group本身 =&gt; Group 模組裡包類別(module including class)123456789module Group puts \"Self inside Group is: #&#123;self&#125;\" # =&gt; Self inside Group is: Group class Louis puts \"Self inside Group is: #&#123;self&#125;\" # =&gt; Self inside Group is: Group::Louis endend 這裡的class是包在module裡面，所以這裡的self是Group::Louis 繼承(inheritance)時的self1234567891011class Lion def say puts self endendclass Pig &lt; Lionendponpon = Pig.newponpon.say # =&gt; #&lt;Pig:0x00007fcb8801ca38&gt; 此時的self為Pig class所產生的實體 引入模組(include module)時的self123456789101112module Pig def say puts self endendclass Lion include Pigendmufasa = Lion.newmufasa.say # =&gt; #&lt;Lion:0x00007fa502824390&gt; 此時的self為Lion class所產生的實體 總結 在實體方法、繼承、引入模組都使用了實體方法，所以此時的self都為該類別所產生的實體。 在類別方法、類別定義、模組定義時，self都為該類別、模組本身。 在模組裡包類別時，self為”模組::類別“。 參考資料：Self in Ruby:A Comprehensive OverviewUnderstanding self in Ruby@/@@ vs. self in RubyRuby’s Main Object (Top Level Context)Rubyのselfが微妙に意味がわからなかったので、様々な文脈（トップレベル、class定義内、method定義内、module定義内）で出力してみたRuby 中的self變數以及應用 “Our greatest weakness lies in giving up. The most certain way to succeed is always to try just one more time.” — Thomas Edison, Inventor","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day6: 類別(Class)與模組(Module)的差異","slug":"2019/鐵人賽Day 6","date":"2019-09-19T04:10:40.000Z","updated":"2020-09-29T09:18:55.790Z","comments":true,"path":"2019/鐵人賽Day 6/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%206/","excerpt":"","text":"在寫這篇文章前，自認如果今天面試被問到這題，預期腦袋裡會一片空白，只知道這兩個物件都長得非常像但說不出哪裡不同。 google一下，看到最多次的一句話： Module is similar to a class but it cannot be “inheritance” and “instantiated”. 咦？那結論都寫在這了，那是不是不用寫文章了(撒花)？ 想了想還是認份的整理一下好了…總要自己驗證一下 開啟irb 可以看到Class背後的老爸竟然就是Module本人啊啊啊啊啊～(腦袋莫名冒出鍾楚雄…) 那既然類別class是模組Module繼承來的，那代表class有的，Module一定都有，但Module有的，class不一定都有，聽起來很像繞口令，來驗證一下看看哪裡不同。 找出差異Module與class的關係看起來就像這樣，要找出差異，我想小學數學有教過，一個大圓包含一個小圓，如果要找出他們不同的地方，只要大圓減去小圓即可。 123#irb2.6.3 :012 &gt; Class.methods - Module.methods =&gt; [] Module與class的類別方法互相減去，得到的是一個空陣列，代表他們在類別方並沒有差別，再來看實體方法： 123#irb2.6.3 :013 &gt; Class.instance_methods - Module.instance_methods =&gt; [:allocate, :new, :superclass] 其中allocate與new是跟產生實體有關係，superclass是與繼承有關係，所以可以看得出來： ==模組(Module)比類別(Class)多了「產生實體」與「繼承」的功能==備註：關於allocate與new 123456789101112class Cat attr_accessor :name def initialize @name = \"NoName\" endendcat1 = Cat.newp cat1.name # =&gt; \"NoName\"cat2 = Cat.allocatep cat2.name # =&gt; nil allocate和new的差別在於：allocate不會用initialize的方法並回傳實體變數，而new會。 何時會使用到Module?給大家一個例子想像一下： 湘北高校籃球社的同學們突然覺得打籃球打贏山王工業就滿足了，於是就約了烏野高校排球社的同學去打排球。 因為櫻木跟大猩猩等人都沒打過排球，所以為了要讓球打得起來，必須把小不點的打排球技能學起來，那我們可以用哪種方式？ 直接寫舉球、托球…等等的技能類別，然後叫湘北類別去繼承他問題：這樣設計就很像「為了想打”一場”排球就轉學去烏野高校」的感覺…幹嘛為了打排球就轉學啊？ 直接寫舉球、托球方法到湘北類別裡面問題：這樣寫似乎也沒不行，但如果今天山王工業的人突然也想加入打排球，那不又要再山王工業的類別裡加入舉球、托球方法… ==這時候就是用Module的時機了== 1234567891011121314151617181920212223242526272829module VolleyTeam def set puts '舉球' end def toss puts '托球' endendclass BasketTeam include VolleyTeam #將module include到類別裡 def pass puts '接球後，傳球!' end def shoot puts '接球後，投籃!' end def dribble puts '運球' endendsakuragi = BasketTeam.newsakuragi.pass # =&gt; 接球後，傳球!sakuragi.set # =&gt; 舉球!sakuragi.toss # =&gt; 托球! 之後如果山王工業真的要加入的話： 123class MountainKing include VolleyTeamend 他們就也可以一起加入打排球了 上面例子可以做出一個小總結，如果今天要做的功能(method)在很多類別都會用到的話，就可以都抽出來寫在module裡面，再把它include到類別裡使用，跟Rails裡的Partial render有幾分相似概念。 總結：講了那麼多範(幹)例(話)，其實類別(Class)與模組(Module)的主要差異就一句話： ==模組(Module)不可繼承、不可實體化== 比較 模組(module) 類別(class) 繼承inheritance ✕ ✔ 可實體化instantiation ✕ ✔ 參考資料：vikingcodeschoolruby-doc.orgModules in Ruby: Part IDifference between a class and a moduleRuby 語法放大鏡為自己學Ruby on Rails “Inside of a ring or out, ain’t nothing wrong with going down. It’s staying down that’s wrong.” — Muhammad Ali, Boxer","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day5: yield在method裡的角色","slug":"2019/鐵人賽Day 5","date":"2019-09-18T04:10:40.000Z","updated":"2020-09-29T09:18:55.755Z","comments":true,"path":"2019/鐵人賽Day 5/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%205/","excerpt":"","text":"yield的中文翻譯有很多意思，在程式裡可以翻做「讓」的意思。 那在程式裡，到底是「讓」出什麼東西呢？ p.s不知道為何打到這裡腦袋突然出現扶老太太過馬路 yield下面例子say_something方法，下方有個掛載的block，yield的作用就是「將控制權暫時讓給Block」之後，再繼續回來執行程式。 1234567891011def say_something puts 'This is start' yield puts 'This is end'endsay_something &#123; puts 'Block aboard!'&#125;# =&gt; This is start# Block aboard!# This is end 程式執行的流程：從第2行印出’This is start’，再往下時遇到yield，暫時將控制權移交給第7行印出’Block aboard!’後，又回到第4行印出’This is end’。 下面例子其實跟上面雷同，只是多一個class而已。 12345678910class Hero def heart_beating yield endendking = Hero.newking.heart_beating &#123; p '帝王引擎' &#125;# =&gt; 帝王引擎 yield後面可以帶一個或以上的參數在yield的後面可以自帶參數，延續上面的例子 1234567891011121314151617class Hero def heart_beating yield end def one_punch yield '反覆橫跳' endendking = Hero.newking.heart_beating &#123; p '帝王引擎' &#125;# =&gt; 帝王引擎saitama = Hero.newsaitama.one_punch &#123;|skill| p \"必殺認真系列..#&#123;skill&#125;\" &#125;# =&gt; \"必殺認真系列..反覆橫跳\" 同一個method裡面塞多個yield123456789101112131415161718192021class Hero def heart_beating yield end def one_punch yield '反覆橫跳' yield '連續普通拳' yield '認真拳' endendking = Hero.newking.heart_beating &#123; p '帝王引擎' &#125;# =&gt; 帝王引擎saitama = Hero.newsaitama.one_punch &#123;|skill| p \"必殺認真系列..#&#123;skill&#125;\" &#125;# =&gt; \"必殺認真系列..反覆橫跳\"# \"必殺認真系列..連續普通拳\"# \"必殺認真系列..認真拳\" 讓程式判斷何時要yeildRuby有內建一個方法 block_given? 123456def optional_block yield('還我漂漂拳') if block_given?endp optional_block # =&gt; niloptional_block &#123;|x| puts \"#&#123;x&#125;\" &#125; # =&gt; 還我漂漂拳 如果有給block，就yield控制權出去給block。 yield後面可以帶多個參數12345678910111213141516171819def calculator(a, b) yield(a, b)endputs calculator(5, 6) &#123; |a, b| a + b &#125; # =&gt; 11puts calculator(5, 6) &#123; |a, b| a - b &#125; # =&gt; -1def yield_with_arguments yield \"巴達獸進化~~~~~~~\" last_name = 'John' first_name = 'Cena' yield(last_name, first_name)endyield_with_arguments &#123; |l, f| puts \"#&#123;l&#125; #&#123;f&#125;\" &#125;# =&gt; 巴達獸進化~~~~~~~# John Cena 巴達獸進化 yield組合技範例一：第7行的i被yeild出去找了第11行的i，x則是實體變數@v用each方法印出陣列中的數字。 12345678910111213141516171819class Map def initialize @v = [1, 2, 3, 4] end def each_print @v.each&#123;|i| puts yield i &#125; if block_given? endendi = \"I can count number\"a_obj = Map.newa_obj.each_print&#123;|x| \"#&#123;i&#125; #&#123;x&#125; \" &#125;# =&gt;# I can count number 1# I can count number 2# I can count number 3# I can count number 4 範例二：針對第4行中的counter去yield給method外部的block，且first給預設值=1。可以看到給first參數值，在第4行的counter就會走block中的方式，且從給的值開始往下走。(備註：next方法可以找下一個數字或字母) 12345678910111213141516171819202122232425def list(array, first = 1) counter = first array.each do |item| puts \"#&#123;yield counter&#125;. #&#123;item&#125;\" counter = counter.next endendlist([\"a\",\"b\",\"c\"]) &#123; |ary| ary &#125;list([\"a\",\"b\",\"c\"], 100) &#123; |ary| ary &#125;list([\"Ruby\", \"Is\", \"Fun\"], \"A\") &#123; |ary| ary &#125;#output# 1. a# 2. b# 3. c# 100. a# 101. b# 102. c# A. Ruby# B. Is# C. Fun 總結：yield就是暫時把控制權交棒給method外的 Block，等 Block 執行結束後再把控制權交回來method，並繼續往下走到程式結束。 yield的使用時機，可能因為做的練習跟專案還不夠多，暫時還不確定到底會在哪個情境使用到yield，但可以從上面幾的範例感受到，如果要針對method內某個變數的值去做改變的話，可用yield的方式將控制權讓出給寫在method外的block去做運算。 參考資料：I don’t really understand what is this yieldBlocks and yields in RubyMastering Ruby Blocks in Less Than 5 MinutesThe Ultimate Guide to Blocks, Procs &amp; LambdasThe yield Keyword in Ruby為自己學Ruby on Rails活用Ruby裡的yield “Most of the important things in the world have been accomplished by people who have kept on trying when there seemed to be no hope at all.” – Dale Carnegie, Motivational Expert","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day4: Block程式碼區塊及Proc, Lambda差異","slug":"2019/鐵人賽Day 4","date":"2019-09-17T04:10:40.000Z","updated":"2020-09-29T09:18:55.720Z","comments":true,"path":"2019/鐵人賽Day 4/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%204/","excerpt":"","text":"Block in Basketball Ruby是一個「物件導向」相當徹底的一門程式語言，幾乎所有的東西都是物件，例如： 數字 Integer 符號 Symbol 字串 String 陣列 Array 雜湊 Hash 為什麼說”幾乎”呢？ Block(程式碼區塊)在寫各種迴圈的時候，會大量的運用到Block: 12345678910numbers = [1,2,3,4,5]p numbers.map&#123;|num| num * 2&#125; #印出[2,4,6,8,10]p numbers.select&#123;|num| num.odd?&#125; #印出[1,3,5]p numbers.reduce(0)&#123;|accu,num| accu + num &#125; #印出155.times &#123; puts \"Hello\" &#125; #印出5次Hellonumbers.each do |num| num * 2 #印出[2,4,6,8,10]end 在Ruby，{ … }及do end就是Block，且前面要接一個method。 ==Block並不是物件，本身不能獨立存在。==12puts &#123;\"Hello, World!\"&#125; #會出現語法錯誤sentences = &#123;\"Hello, World!\"&#125; #會出現語法錯誤 讓Block獨立存在的方法: Proc , Lamda雖然Block不是物件，但Ruby有內建兩個方法可以使Block物件化。 Proc12ninjutsu = Proc.new &#123;puts 'らせん(螺旋)がん(丸)'&#125;ninjutsu.call #印出 らせん(螺旋)がん(丸) 可以用call的方式呼叫，且可以帶參數 123456789101112131415#call方法呼叫calculator = Proc.new &#123;|num| puts num * 2&#125;calculator.call(5) #印出 10#call()方法且帶參數呼叫def sushi_plate(price) return Proc.new &#123;|num| num * price&#125;endnigili = sushi_plate(50) #100avacado = sushi_plate(30) #150puts \"Nigili is $#&#123;nigili.call(2)&#125; and avacado is $#&#123;avacado.call(5)&#125;.\"#印出Nigili is $100 and avacado is $150. ==注意!!!== 1Proc.new &#123; return ... &#125; return請不要寫在Proc的Block裡，否則程式碼執行到這段後就會停止(return完後立即停止)，不會繼續往下走。 1234567891011def proc_airline p \"strat from TPE\" airline_proc = Proc.new &#123; return \"Eva airline\" &#125; airline_proc.call p \"has arrived NRT\"end p proc_airline #印出\"strat from TPE\" # \"Eva airline\" #\"has arrived NRT\"不會印出，因為在第3行就停止了。 Lambda有點類似匿名函式 1234567#方式一：calculator = lambda &#123;|num| puts num * 2&#125;calculator.call(5) #印出 10#方式二：calculator = -&gt; (n) &#123;puts n * 2&#125;calculator.call(5) #印出 10 Proc與Lambda的差異這樣比較起來，兩個東西看起來真的非常相似，但他們之間還是有一點點的差異存在，我們來看以下例子： 差異1.若block預期有參數要帶入，Lambda的call不給參數會出現錯誤，Proc的call則不會出錯而是會回傳nil 1234567lambda = -&gt; (name) &#123; puts \"Hello #&#123;name&#125;\" &#125;lambda.call(\"Ruby\") #印出 Hello Rubyproc = Proc.new &#123; |name| puts \"Hello #&#123;name&#125;\" &#125;proc.call(\"Ruby\") #印出 Hello Ruby 目前看起來都很正常，但再看下面： 1234lambda.call()#出現error:wrong number of arguments (given 0, expected 1) (ArgumentError)proc.call() #印出 Hello Lambda函式若有預期要傳入參數但call卻沒有給的話，會直接跳出錯誤訊息，Proc後的call雖然也沒有給參數，程式還是可以過的，因為Proc會自動給nil 差異2.Proc的block裡若有return，會直接終止程式不繼續往下走，Lambda則不影響，會完整跑完程式。 1234567def proc_pikachu proc = Proc.new &#123; return &#125; proc.call p \"使用鋼鐵尾巴！！\"endproc_pikachu # 印不出 \"使用鋼鐵尾巴！！\" 1234567def lambda_pikachu lam = -&gt; &#123; return &#125; lam.call p \"使用鋼鐵尾巴！！\"endlambda_pikachu # 印出\"使用鋼鐵尾巴！！\" The difference between procs and lambdas is how they react to a return statement. A lambda will return normally, like a regular method. But a proc will try to return from the current context.The reason is that you can’t return from the top-level context. from rubyguides 簡單總結一下：Block不是物件，不能獨立存在。 Proc可帶參數，要求有參數，call卻沒給參數時會回傳nil，{return…}會跳出程式。 Lambda使用起來更像我們一般使用的method，且會嚴格要求參數數目，就算{return…}也會把程式跑完。 參考資料：rubyguidesModules in Ruby: Part IIWhat are Lambdas in Ruby?Using Lambdas in Ruby為你自己學Ruby on Rails “Perseverance is not a long race; it is many short races one after another.” – Walter Elliott, Clergyman","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day 3: Ruby世界中的符號(Symbol)是什麼？與字串(String)有什麼差異？","slug":"2019/鐵人賽Day 3","date":"2019-09-16T04:10:40.000Z","updated":"2020-09-29T09:18:55.680Z","comments":true,"path":"2019/鐵人賽Day 3/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%203/","excerpt":"","text":"我在剛接觸符號(Symbol)這個名詞的時候，心裡想的是： 覺得哇～原來寫程式也可以玩emoji(被打..) 現在想起來還真的是蠢到不行，我想就算是新手也沒像我這麼單(愚)純(蠢)吧XD 符號(Symbol)在Rails專案裡，我們常常看到冒號加上英文字母的用法，例如:name,age,party,policy 123def clean_params params.require(:candidate).permit(:name, :age, :party, :policy)end 或是Hash 1student = &#123;:name =&gt; 'Louis', :age =&gt;'18'&#125; 冒號的後面其實也非必要加英文，你要變成:やさしい,:帥哥,:123也是會過的，只是在使用上很不方便且很少見，建議還是用英文字母就好。 其實符號(Symbol)與變數(variable)的命名很像，只是符號前面有加冒號的差別而已。 有些人會認為，阿這東西不就記下來就好？幹嘛還要特別開一篇來寫？符號在Ruby裡是很重要的存在，它並不只是像變數命名一樣，只是個’名字’的存在。可以想像成符號就是「有名字的物件」且「無法變更的字串(String)」。 12345x = 1 #數字物件x = 'good' #字串物件x = :good #符號物件 字串(String)與符號(Symbol)有什麼不同？==字串的內容可以被修正，但符號不行。==開啟irb來看一下： 123456789101112131415# 改變字串2.6.3 :016 &gt; a = &apos;hello&apos; =&gt; &quot;hello&quot;2.6.3 :017 &gt; a[0] =&gt; &quot;h&quot;2.6.3 :018 &gt; b = :hello =&gt; :hello2.6.3 :019 &gt; b[0] =&gt; &quot;h&quot;2.6.3 :020 &gt; a[0] = &apos;f&apos; =&gt; &quot;f&quot;2.6.3 :021 &gt; a =&gt; &quot;fello&quot; #字串的第一個字母&apos;h&apos;改成&apos;f&apos;2.6.3 :022 &gt; 123456789# 改變符號，出現error2.6.3 :022 &gt; b = :hello =&gt; :hello2.6.3 :023 &gt; b[0] =&gt; &quot;h&quot;2.6.3 :024 &gt; b[0] = &apos;f&apos;NoMethodError (undefined method `[]=&apos; for :hello:Symbol) Symbol的效能比字串好記憶體的存取方式也不同： 1234567891011# 符號(Symbol)每次印出 :name 時，具有唯一性，佔用記憶體位址相同。2.6.3 :012 &gt; :name.object_id =&gt; 880282.6.3 :013 &gt; :name.object_id =&gt; 88028# 字串(String)每次印出&quot;name&quot;時，他的object_id都會不同，佔用的記憶體位址也不同。2.6.3 :014 &gt; &apos;name&apos;.object_id =&gt; 701834869593602.6.3 :015 &gt; &apos;name&apos;.object_id =&gt; 70183486974200 每個Symbol產生時，在Ruby裡就會產生一個獨立的object_id，直到程式結束為止，而字串在每次產生的時候，都會產生一個新的object_id，這也是為何「字串的內容可以被修正，但符號不行。」的原因。 也因為每次取用一次String，就得產生一個新的object_id，很佔用記憶體空間，Symbol則是直接取用一開始建立的object_id，所以字串的效能稍微差一點。 String可以轉成Symbol，Symbol也可以轉成String1234567# 字串轉成 Symbol2.6.3 :025 &gt; &apos;name&apos;.to_sym =&gt; :name# Symbol 轉成字串2.6.3 :026 &gt; :name.to_s =&gt; &quot;name&quot; 參考資料：PJChen的私房菜Ruby語法放大鏡 “When there’s that moment of ‘Wow, I’m not really sure I can do this,’ and you push through those moments, that’s when you have a breakthrough.” — Marissa Mayer, CEO of Yahoo","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"Day 2: 變數(variable)與常數(Constant)","slug":"2019/鐵人賽Day 2","date":"2019-09-15T04:10:40.000Z","updated":"2020-09-29T09:18:55.626Z","comments":true,"path":"2019/鐵人賽Day 2/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%202/","excerpt":"","text":"從開班到現在學了兩個月，只知道這兩個東西每天都在用，但要直接解釋出”變數”與”常數”是什麼？還是得稍微轉一下才能夠說明，所以就特別針對這個主題來寫一下吧！ 什麼是變數(variable)？變數在數學上的定義，被用來表示值的一個’符號’(此指數學符號)，且這個值可以是指定的或是未被指定的。 但程式中的變數呢？ 變數：類似代名詞，有點像幫某個東西命名，其實就像標籤。這樣講可能很抽象，但可以試著這樣理解:一個籃子裡面裝了一個值是2(指定)，再給籃子一個標籤(變數)命名叫做X, X = 2 當然這個值我們要放什麼型態的資料都可以，這裡只是舉例給它個Integer型態，下篇會來解釋Ruby的型態有哪些。 圖片來源：https://www.complexsql.com/ 變數的種類 區域變數（local Variable)：定義在方法(method)裡面的變數，只能在method裡使用。預設值：沒有12345def test x = 2endp x #印出2 實體變數（instance variable):預設值：nil在類別(class)裡通常會有不只一個method，但一般的變數只能在自己的method中取用，故使用實體變數，讓class裡的每個method都可以取用這個變數，且變數的值(value)會根據不同的method儲存不同的value。 另外，實體變數要在class中互相取值前有個先決條件：必須將物件實體化(initialize)之後才能互相使用。 123456789101112class Cat def initialize(item) #類似’創角色(item)‘的概念 @item = item end def calculate #實體方法 @item * 2 #取用實體變數前面要加'@' endendkitty = Cat.new(2)p kitty.calculate #印出4 類別變數（class variable）:預設值：沒有可以在同一個類別(class)或子類別中共用的變數，所以翻譯成白話文，“實體變數”只能遊走在自己class中的method，而“類別變數”除了可以遊走自己的class之外，還可以去其他的子類別被使用。 12345678910class Language @@name = 'english' #類別變數前面要加'@@' def self.speak #要做用在類別上，所以要用類別方法 puts @@name endendLanguage.speak #印出english 全域變數（global variable）：預設值：nil全域變數以$開頭，可以從程式裡的任何地方開始。也因為可以寫在任何地方的特性，故在使用的時候也相對危險。 什麼是常數(Constant)?一張有寫著名字的標籤，貼在某個東西上面。其中常數本身不帶任何型態，且最重要的一點，在Ruby裡面的常數，第一個英文字母要大寫，這也是為何我在標故意把variable跟Constant的第一個字母做大小寫區別的原因。 另外，常數是可以被修改的 “The secret of success is constancy to purpose.” – Benjamin Disraeli, British Prime Minister","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"鐵人賽Day 1: 參賽起始文","slug":"2019/鐵人賽Day 1","date":"2019-09-14T04:10:40.000Z","updated":"2020-09-29T09:18:55.577Z","comments":true,"path":"2019/鐵人賽Day 1/","link":"","permalink":"https://louiswuyj.site/2019/%E9%90%B5%E4%BA%BA%E8%B3%BDDay%201/","excerpt":"","text":"其實自認自己是個對文字有恐懼的人，更別說是寫文章了。算是給自己的一次挑戰，並養成將學到的新知識轉換成文字的習慣，除了能幫助自己回頭看學習的歷程當筆記用外，也許也能夠幫助一些人吧（應該吧？ 參賽動(衝)機(動)「沒時間啦….我光每天吸收新知識、複習課程內容都應付不來了，還要開始run專案，而且$%#$#)$@…」「寫文章又沒人看，搞不好還給別人見笑咧～」「如果志在參加隨便發文，我不就只是花了30天發了30篇廢文嗎？」「但我只是小嫩嫩阿…寫出來的東西真的能看嗎？」 以上這些都是我報名前的心聲，我想一定有很多人都有跟我一樣的想法，但為何我還是會報名？ 「時間就像擠乳溝，硬擠一下就有了。」 沒有時間，其實只是給自己偷懶的藉口，當我意識到這件事的時候，身邊的同學各個都已經報名，他們也不是都有時間的人，沒有多想，反正衝就對了。身為新手而且又是報名自我挑戰組，就算失敗了又如何？反正寫了又不見得有人會看，又不是偶像，哪來偶包？ 主題發想就新手而言，要我寫個「從0到30天學會RoR」，我想寫出來的應該只會是幹話吧XD與其說要想個主題出來，我倒認為不如把我在轉職過程中學到的觀念，把自己相對不熟悉的部分分享出來，也許中間的順序跟過程或沒有連貫，但我就當作是給自己看的東西，隨我發想就好(誤) 既然現在自己比較偏重用RoR寫後端，且也對這部分比較感興趣，那就以它為當為主題吧！ 寫文內容預計記錄從初學Ruby到應用在Rails中學習到的觀念，以及可能會被問到的面試問題去撰寫。覺得要完成挑戰，實在很需要雞湯文，所以我想在每篇文章的結尾加上一句雞湯句(或幹話？)，以鼓勵自己繼續堅持下去。 如果未來寫的文章或是觀念有出入的話，也請各位大大不吝指教了。 Most of the important things in the world have been accomplished by people who have kept on trying when there seemed to be no hope at all. – Dale Carnegie","categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"}],"tags":[{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"}]},{"title":"5xRuby：滿一個月","slug":"2019/5xRuby：滿一個月","date":"2019-08-16T04:10:40.000Z","updated":"2020-09-29T09:18:55.315Z","comments":true,"path":"2019/5xRuby：滿一個月/","link":"","permalink":"https://louiswuyj.site/2019/5xRuby%EF%BC%9A%E6%BB%BF%E4%B8%80%E5%80%8B%E6%9C%88/","excerpt":"","text":"啟程還記得07/15開課當天，早上還在東京趕飛機的我，匆匆忙忙在下課前一小時衝進教室，滿頭大汗地隨便抓個位置坐在教室裡，根本不敢相信自己真的正式準備踏入這圈子了，心情既興奮又擔心，但既然都已經下定決心要挑戰，不管最後的結果如何，自己的選擇，就要對自己負責，不畏挫折踏實努力的走完這三個月的精實訓練，看看自己的最大能耐會走到多遠吧！ 過程 第一週： 還記得第一週龍哥教的Ruby，以及Amos教的html，除了一開始的Git有遇到一些挫折，其他的部分還算得心應手，畢竟之前算有在AC線上課程自學一個月…. ＢＵＴ！！！ 人生就是會有個BUT，沒想到前一個月的自學量，在短短一週的資訊量就被超過的連車尾燈都看不到，果不其然是名副其實的精實營，且作業方面就讓我深刻的體會到，身為工程師的日常生活就是在不停的挫折、不停的戰鬥中，獲得成就感。 第二週： CSS及Ruby的雙重轟炸，我目前最大的挫折大概就是死在這週。CSS選取器選半天選不到、float用半天排不好版，Ruby的實體方法、類別方法的觀念理解、Class繼承等等等….在這週的作業，完全被打的體無完膚，一個Ruby題目像題目像下圖： 我就跟他耗了將近三小時！！！而且還沒寫出結果，再看CSS題目： 花費時間也超過3小時，現在回頭看當時的自己，真的是很嫩呢XD 還好有了老爸Matz桑的信心喊話，以前當晚在Pic Collage參加的Ruby Conf-pre party，與來自台灣及各國的大神聊天後，對自己稍微又有了點動力繼續走下去。最後終於憑著強大的心臟(其實是無知!?)到處撞牆，就這樣讓我撞到了第三週。 第三週 這週的CSS終於學了display:inline-block的方式切版，終於可以站拋棄float了(撒花)，以及絕對定位、相對定位等，這些雖然是個好用的工具，但其背後的真的很吃觀念，還好老師非常重視“觀念推導”而非只是教我們死記。但寫作業的部分就…才知道上課聽得懂，跟實際拿來用完全是兩馬子事啊… https://codepen.io/LouisYJ/pen/jONqzmd 這份作業就花了我近18小時的時間，真的切到很崩潰…花那麼多時間主要是因為第一次是純用float切版，後強迫自己用inline-block再切一次，確認觀念及工具是否真的都會用了。雖然切的很崩潰，但算是第一次寫到有成就的moment。 但…… 這週的Ruby又讓我崩潰了……Module、Block、namespace、rake等等等，又一堆的新觀念要導入，作業上再度花了近10小時才產出。而且龍哥從這次的作業繳交方式，從原本只要錄影自己打code的過程就好，還要再加上自己的聲音，一邊寫code一邊講解。 剛開始其實還蠻排斥這種方式，但後來其實很感謝當時的自己還是花時間嘗試去做“講解”這件事，畢竟如果我能夠邊coding邊說明，代表我真的懂觀念且已經可以融會貫通了(吧)。花了很多時間寫作業，但也慢慢找到自己的節奏及成就感。 第四週 很快的來到了Amos課的最後一週，終於把大絕招flex交給我們了XD，用起來真的是非常舒服，但只維持了一天的成就感，隔天立馬被RWD打死…. 天哪！！！原來我們切版還要顧慮到不同裝置(手機、平板、電腦)的尺寸(直看、橫看)去客制那個裝置的版，我一直以爲那是電腦自動調整的(超天真)…Amos從最傳統的尺寸計算(大崩潰)，到用calc計算(中崩潰)，到最後的用隔線系統(小崩潰)，看都看得懂，實際應用又是另一回事。 為了能夠讓我們熟悉業界常用的方式，Amos一次出了14個切版作業，一直到現在我都還沒寫完，只能維持一日切一版的節奏慢慢前進，但確實在不斷不斷的練習之下，有發現自己的經驗值似乎在不知不覺中已慢慢提升，切版的速度越來越快且選取器及命名也越來越清楚，過程中有挫折，但似乎也漸漸習慣了。 最後一堂的Boostrap，原來有那麼好用的東西!!!!!有點我們之前到底在學什麼的感覺XD，但樣板是樣板，未來的客戶需求不可能都靠樣板去套就解決，故還是要有一定的手刻切版基礎，才能將樣板跟手刻版做好平衡。 Ruby不知道是開竅了還是靈感乍現!?這兩次近30題的作業，不能說是寫得得心應手，但挫折感明顯比前幾週少非常多，且速度也快多了，雖然常常被龍哥說： ”在Ruby裡還有更簡單的方法“ 但至少我寫出結果來了(誤) 有時候其實會懷疑，過度依賴Ruby的method是不是件好事？所以在每次寫完作業後，有時間我會刻意讓自己去用土炮的方式完成作業，多訓練自己的邏輯思維，讓自己未來若跨到其他語言系，不會因為沒有method可用就躺平在那吃土(笑)(這週五颱風假賺到一天自習，可能這也是壓力比較可以調適的原因!?) 結語第一天的自己，經過了這一個月的訓練，明顯感覺得到自己的進步，但其實不能夠因此自滿，班上的強者實在太多了，既然怎麼追都追不上，那就跟自己比較吧～ 心態調適真的很重要，未來進這行一定是在無盡的挫折跟成就感間不停徘徊，還好在自己心裡層面很低潮的時候，身邊總是有人願意拉我一把告訴我要堅持下去，我算是幸福的吧！ 我不知道後面兩個月過後，是否能夠順利的轉職成功，但至少能夠確認的是： ”我覺得寫程式還蠻有趣的。“","categories":[{"name":"心得相關","slug":"心得相關","permalink":"https://louiswuyj.site/categories/%E5%BF%83%E5%BE%97%E7%9B%B8%E9%97%9C/"}],"tags":[{"name":"上課心得","slug":"上課心得","permalink":"https://louiswuyj.site/tags/%E4%B8%8A%E8%AA%B2%E5%BF%83%E5%BE%97/"}]},{"title":"寫javascript-資料結構初體驗","slug":"2019/寫javascript-資料結構初體驗 copy","date":"2019-08-15T04:10:40.000Z","updated":"2020-09-29T09:18:55.539Z","comments":true,"path":"2019/寫javascript-資料結構初體驗 copy/","link":"","permalink":"https://louiswuyj.site/2019/%E5%AF%ABjavascript-%E8%B3%87%E6%96%99%E7%B5%90%E6%A7%8B%E5%88%9D%E9%AB%94%E9%A9%97%20copy/","excerpt":"","text":"五倍的課程進行將近一個月，終於有了第一次有小組討論XD從來沒接觸過資料結構的我們，從老師訂的題目”購物車“開始發想： 我們討論經過的步驟：1.列出所有購物車會有的功能2.將同種類的進行分類3.將重複的功能刪除4.列出進入購物車選單後的順序流程5.不會變動的功能與會變動的功能進行分類6.會有value的用Objuect，不用特別輸入value的用Array7.寫成code 所以產出了以下基本結果：購物車：{帳號、密碼}購物車 {商品名稱、金額、特價、數量、尺寸、顏色、折扣{購物金、活動優惠、紅利折抵}、總件數推薦商品、瀏覽紀錄}待買清單追蹤清單商城規範會員資料 {姓名、信箱、電話、地址、會員等級}配送方式 {超商: 運費、宅配: 運費、郵局: 運費、面交: 免運費}付款方式 [ATM、信用卡、貨到付款、第三方支付]發票載具 [二聯、三聯、捐贈、電子發票]訂單編號(123代表型態是number, 0.7代表型態是float) 寫成code後產出以下結果： 泰安老師的評語：1.第3行，問題零：Ans: 最外面已經let card了，裡面的key要避免使用同樣名稱的命名。2.第4行～第12行，問題一：問：item這裡只有一個，如果今天有多個item的話，這樣子的資料結構可以寫在哪裡呢？(我在台上空氣凝結…)Ans: 這種寫法基本上可說是設計錯誤，應該會如下圖寫，用Array包住Object才能夠在資料上儲存多筆item。 3.第13行，問題二：問：那個總金額是…?直接輸入字串？Ans:關於要做運算的事情，不需要寫在資料結構裡面，只要再外面用function運算完後再輸入回去就好。 4.第16行~第17行，問題三：問：商品名稱跟瀏覽紀錄..?一個字串？Ans:同問題一，應有多筆資料的儲存應用Array包住Object。 5.第20行～第21行，第22行～第27行，問題四：Ans:同問題一，應有多筆資料的儲存應用Array包住Object。 補充：在item的部分，其實並不是你在Array裡寫幾個Object，就只能在購物車裡放幾個不同item，而是一開始的資料其實是個空陣列，當使用者按下”加入購物車”後，才會傳入一個資料進入Array。 結論：1.若是同樣的東西，卻需要有多筆的時候，使用Array包住裡面的資料。2.若只有單筆需要帶入key跟value的時候，使用Object。(第２９行)3.避免key的命名與外部的變數名稱相同。當然就算這樣設定，這樣的資料結構其實也還算是有問題的，但藉由此例大概可以對第一次寫資料結構的我們，有了一些些感受跟體驗。","categories":[{"name":"javascript","slug":"javascript","permalink":"https://louiswuyj.site/categories/javascript/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"https://louiswuyj.site/tags/javascript/"}]}],"categories":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/categories/Ruby-on-Rails/"},{"name":"開發相關","slug":"開發相關","permalink":"https://louiswuyj.site/categories/%E9%96%8B%E7%99%BC%E7%9B%B8%E9%97%9C/"},{"name":"Git","slug":"Git","permalink":"https://louiswuyj.site/categories/Git/"},{"name":"心得相關","slug":"心得相關","permalink":"https://louiswuyj.site/categories/%E5%BF%83%E5%BE%97%E7%9B%B8%E9%97%9C/"},{"name":"javascript","slug":"javascript","permalink":"https://louiswuyj.site/categories/javascript/"}],"tags":[{"name":"Ruby on Rails","slug":"Ruby-on-Rails","permalink":"https://louiswuyj.site/tags/Ruby-on-Rails/"},{"name":"iterm2","slug":"iterm2","permalink":"https://louiswuyj.site/tags/iterm2/"},{"name":"鐵人賽","slug":"鐵人賽","permalink":"https://louiswuyj.site/tags/%E9%90%B5%E4%BA%BA%E8%B3%BD/"},{"name":"Git","slug":"Git","permalink":"https://louiswuyj.site/tags/Git/"},{"name":"GitHub","slug":"GitHub","permalink":"https://louiswuyj.site/tags/GitHub/"},{"name":"上課心得","slug":"上課心得","permalink":"https://louiswuyj.site/tags/%E4%B8%8A%E8%AA%B2%E5%BF%83%E5%BE%97/"},{"name":"javascript","slug":"javascript","permalink":"https://louiswuyj.site/tags/javascript/"}]}